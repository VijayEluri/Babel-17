\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{listings}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Syntax and Semantics of Babel-17, v0.21 (Draft)}
\author{Steven Obua}
\date{\today}                                          
\newcommand{\metababel}[1] {\textsl{#1}}
\newcommand{\tabparbox}[1] {\parbox{12cm}{

\vspace{0.1cm}
#1
\vspace{0.1cm}
}}
\newcommand{\patterndescr}[1] {\parbox{9cm}{
\small
\vspace{0.1cm}
#1
\vspace{0.1cm}
}}
%\newcommand{\babelsrc}[1] {\texttt{#1}}
\newenvironment{babelcode}[0]{\begin{center}\tt}{\end{center}}

\lstdefinelanguage{babellanguage} 
{morekeywords={lazy, concurrent, match, case, exception, begin, end, random, choose,force,true, false, infinity, val, def, this, object,if,then,else,elseif,memoize,for,in,yield,while,do,with,nil},
sensitive=true, 
morecomment=[l]{//}, 
morecomment=[s]{/*}{*/}, 
morestring=[b]", 
} 

\lstset{language=babellanguage,mathescape=true,float, xleftmargin=1.5cm,columns=flexible}

\lstnewenvironment{babellisting} 
{\small} 
{} 

\newcommand{\babelsrc}[1] {\lstinline!#1!}


%\newenvironment{babellisting} [0]{\begin{center}\begin{babellistingfree}}{\end{babellistingfree}%\%end{center}}

%lstset{language=babellanguage,mathescape=true}\begin{lstlisting}}{\end{lstlisting}\end{center}}

 
\begin{document}

%\begin{abstract}
%Babel-17 is an evolving new programming language. In this paper I present Babel-17 v0.2. 
%\end{abstract}


\maketitle

\tableofcontents


\section{Introduction}
The first question that someone who creates a new programming language will  hear from others inevitably is: Why another programming language? Are there not already enough programming languages out there that you can pick from?

I always wanted a programming language 
\begin{itemize}
\item in which I can express myself compactly and without jumping through too many hoops, 
\item that is easy to understand and to learn,
\item in which purely functional programming is the default and not the exception,
\item that supports exceptions,
\item that has pattern matching,
\item that has built-in support for laziness and concurrency,
\item that has lists, vectors, sets and maps,
\item that seamlessly marries structured programming constructs like loops with purely functional programming,
\item that supports objects, modules and data encapsulation,
\item that has mature implementations for all major modern computing platforms,
\item that is beautiful.
\end{itemize}
There is no such language out there. Therefore I decided to create one. When Babel-17 will have reached v1.0 then the above goals will have been achieved. The version described in this document is Babel-17 v0.21, so there is still some distance to go. 

Babel-17 is not a radically new or revolutionary programming language. It picks those raisins I like out of languages like Standard ML, Alice ML, Java, Javascript, Scala, Erlang, Haskell, Lisp, Clojure and Mathematica, and tries to evolve them into a beautiful new design. Of course, what some regard as beautiful, others might find unremarkable, or even ugly.

Babel-17 is a functional language. It is not a pure functional language because it contains sources of non-determinism like the ability to pick one of two values randomly. If you take these sources of non-determinism out of the language, it becomes pure. 

In Babel-17, every value has a type. These types are not checked statically, but only dynamically. 

Babel-17 is also object-oriented in that many aspects of Babel-17 can be explained in terms of sending messages to objects. 

The default evaluation order of Babel-17 is strict. But optional laziness is built into the heart of Babel-17, also, and so is concurrency. 

Babel-17 has pattern matching and exception handling. Both are carefully integrated with each other and with the laziness and concurrency capabilities of Babel-17.

Furthermore, Babel-17 establishes the paradigm of \emph{purely functional structured programming}  via the notion of linear scope.

In this document  I specify Babel-17 in a mostly informal style: formal notation is sometimes used when it supports clarity.

\section{Lexical Matters}
Babel-17 source code is always written UTF-8 encoded. If it ain't UTF-8, it ain't Babel-17. 

Constructors are alphanumeric strings which can also contain underscores, and which must start with a capital letter. 
Identifiers are alphanumeric strings which can also contain underscores, and which must start with a non-capital letter.
The distinction between two constructors or two identifiers is not sensitive to capitalization.

These are the keywords of Babel-17:
\begin{center}
\tt
\begin{tabular}{cccccccc}
begin & end & object & with & if & then & else & elseif \\
while &  for & do & choose & random & yield & match & case \\
as & val & def & in & exception & lazy & concurrent & memoize \\
to & downto & true & false & nil & infinity &  force & 
\end{tabular}
\end{center}
Note that keywords are written always in lower case. For example, {\tt bEGIN} is not a legal keyword, but it also isn't an identifier (because of case insensitivity). Also note that {\tt Begin} and {\tt BEGIN} denote the same legal constructor. When we talk about identifiers in the rest of the paper, we always mean identifiers which are not keywords.

You can write down decimal, hexadecimal, binary and octal numbers in Babel-17. The following notations all denote the same number:
\begin{center}
\tt
\begin{tabular}{cccc}
15 & 0xF & 0b1111 &  0o17
\end{tabular}
\end{center}
Babel-17 also knows the number \babelsrc{infinity}.

Strings start and end with a quotation mark. Between the quotation mark, any valid UTF-8 string is allowed that does not contain newline, backslash or quotation mark characters, for example:
\begin{center}
\begin{tabular}{cccc}
\verb+"hello world"+ & \verb+"$1, 2%"+ & \verb+"1 <= 4! <= 5^2"+
\end{tabular}
\end{center}
Newline, backslash and quotation mark characters can be written down in escaped form. Actually, any unicode character can be written down in its escaped form via the hexadecimal value of its codepoint: 
\begin{center}
\begin{tabular}{r|l}
String consisting only of a quotation mark & \verb+"\""+\\\hline
String consisting only of a backslash & \verb+"\\"+ \\\hline
String consisting only of a line feed & \verb+"\n"+ \\\hline
String consisting only of a carriage return & \verb+"\r"+ \\\hline
String consisting only of line feed via 16-bit escaping & \verb+"\u000A"+ \\\hline
String consisting only of line feed via 32-bit escaping & \verb+"\U0000000A"+
\end{tabular}
\end{center}

Comments in Babel-17 are written between matching pairs of \verb+/*+ and \verb+*/+ and can span several lines.

Finally, here are all ASCII special symbols that can occur in a Babel-17 program:
\newcommand{\mapcurlyleft}{\{|}
\begin{center}
\tt
\begin{tabular}{ccccccccccccc}
\verb+=+ & \verb+==+ & \verb+!=+ & \verb+<+ & \verb+<=+ & \verb+>+& \verb+>=+  &
\verb-+- & \verb+-+ & \verb+*+ & \verb+/+ & \verb+^+ & \verb+;+  \\
\verb-|- & \verb+&+ & \verb+!+ & \verb-++- & \verb+--+& \verb+**+  &
\verb-//- & \verb+,+ & \verb+::+ & \verb+->+ & \verb+=>+& \verb+?+  & \verb+...+  \\
\verb-(- & \verb+)+ & \verb+[+ & \verb+]+ & \verb+{+& \verb+}+  & \verb+.+ &   &
& & & 
\end{tabular}
\end{center}
Table~\ref{table:furthersymbols} lists all other Unicode symbols that have a meaning in Babel-17.
\begin{table}
\caption{Further Unicode Symbols}
\begin{tabular}{c|c|c}
\textbf{Unicode Hex Code} & \textbf{Display} & \textbf{ASCII Equivalent}\\\hline
%\parbox{0cm}{\vspace{0.7cm}}2983 & \texttt{\{\hspace{-0.089cm}∣} & \verb+{|+\\
%2984 & \texttt{∣\hspace{-0.089cm}\}} & \verb+|}+\\
2261 & ≡ & \verb+==+\\
2262 & ≢ & \verb+!=+\\
2264 & ≤ & \verb+<=+\\
2265 &  ≥ & \verb+>=+\\
221E & ∞ & \babelsrc{infinity}\\ 
2227 & ∧ & \verb+&+\\
2228 & ∨ & \verb+|+\\
00AC & ¬ & \verb+!+\\
2237 & :: & \verb+::+\\
2192 & → & \verb+->+\\
21D2 & ⇒ & \verb+=>+\\
2026 & … & \verb+...+\\
\end{tabular}
\label{table:furthersymbols}
\end{table}


\section{Overview of Built-in Types}
Each value in Babel-17 has a unique type. All built-in types are depicted in Table~\ref{table:builtintypes}.
\begin{table}
\caption{Built-in Types of Babel-17}
\begin{tabular}{c|c}
\textbf{Type} & \textbf{Description}\\\hline
\metababel {Integer} & the type of arbitrary size integer numbers\\
\metababel{Infinity} & the type consisting of the values \babelsrc{infinity} and \babelsrc{-infinity}\\
\metababel{Boolean} & the type consisting of the values \babelsrc{true} and \babelsrc{false}\\
\metababel{String} & the type of valid Unicode strings\\
\metababel{List} & the type of lists\\
\metababel{Vector} & the type of vectors / tuples\\
\metababel{Set} & the type of sets \\
\metababel{Map}& the type of maps \\
\metababel{CExpr} & the type of constructed expressions\\
\metababel{Object} & the type of user-defined objects\\
\metababel{Function} & the type of  functions\\
\metababel{PersistentException} & the type of persistent exceptions\\
\metababel{DynamicException} & the type of dynamic exceptions\\
\end{tabular}
\label{table:builtintypes}
\end{table}

\section{Objects and Functions}
All values in Babel-17 are objects. This means that you can send messages to them. Many values in Babel-17 are functions. This means that you can apply them to an argument, yielding another value. Note that for a value to be an object, it does not need to have type \metababel{Object}, and for a value to be a function,  it does not need to have type \metababel{Function}. 

The result of sending message $m$ to object $v$  is written as
\begin{babellisting}
$v$.$m$
\end{babellisting}
Here $m$ is an identifier. 
The result of applying function $f$ to value $x$ is written as 
\begin{babellisting}
$f$ $x$
\end{babellisting}
Note that $f$ $x$ is equivalent to 
\begin{babellisting}
($f$.apply_) $x$
\end{babellisting}
Therefore any object that responds to the \babelsrc{apply_} message can act as a function.
In the above we could also leave out the brackets because sending messages binds stronger than function application. 

Repeated function application associates to the left, therefore 
\begin{babellisting}
$f$ $x$ $y$ 
\end{babellisting} 
is equivalent to \babelsrc{($f$\ $x$)\ $y$}.

\section{Exceptions}
Exception handling in Babel-17 mimicks exception handling mechanisms like those which can be found in Java or Standard ML or Erlang, while adhering at the same time to the functional paradigm .

There are two types of exceptions: \metababel{PersistentException} and  \metababel{DynamicException}.
The difference is that a \metababel{PersistentException}  can be treated as part of any data structure, and is passed around just like any other value, while a \metababel{DynamicException} can never be part of a data structure and has special evaluation semantics. 

Exceptions in Babel-17 are not that special at all but mostly just another type of value.  Let us write \metababel{PersistentException $v$} for a \metababel{PersistentException} with parameter $v$,
and  \metababel{DynamicException $v$} for a \metababel{DynamicException} with parameter $v$. 
We also write \metababel{Exception $v$} for an exception with parameter $v$. The parameter $v$ is a non-exceptional value; this means that $v$ can be any Babel-17 value except one of type \metababel{DynamicException}. Note that $v$ can be non-exceptional and of type \metababel{PersistentException} at the same time.

Then the following deterministic rules govern how exceptions behave with respect to sending of messages, function application, laziness and concurrency:
\begin{babelcode}
\begin{tabular}{rcll}
(\metababel{Exception $v$}).$m$ & $\leadsto$ & \metababel{DynamicException $v$}&\\
(\textsl{Exception} $v$) $x$ & $\leadsto$ & \metababel{DynamicException $v$}&\\
$f$ (\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}& {\rm where $f$ is non-exceptional}\\
exception $v$ & $\leadsto$ & \metababel{DynamicException $v$}&\\
lazy (\metababel{Exception $v$}) & $\leadsto$ & \metababel{PersistentException $v$}&\\
concurrent (\metababel{Exception $v$}) & $\leadsto$ & \metababel{PersistentException $v$}&\\
\end{tabular}\\
\end{babelcode}
Exceptions in Babel-17 are created with the expression \babelsrc{exception $\ v$}. Creating exceptions in Babel-17 corresponds to \emph{raising} or \emph{throwing} exceptions in other languages. There is no special construct for catching exceptions in Babel-17. Instead, catching an exception can be done via the \babelsrc{match} expression which will be described later. 

In a later section, we will describe the  \babelsrc{lazy} and \babelsrc{concurrent} expressions of Babel-17. They are the reason why exceptions are divided into dynamic and persistent ones. 

\section{Laziness and Concurrency}
The default evaluation mechanism of Babel-17 is strict. This basically means that the arguments of a function are evaluated before the function is applied to them. Babel-17 has two constructs to change this default behaviour. 

The expression
\begin{babellisting}
lazy $e$
\end{babellisting}
is not evaluated until it is actually needed. When it is needed, it evaluates to whatever $e$ evaluates to, with the exception of dynamic exceptions, which are converted to persistent ones. It is guaranteed that $e$ is only evaluated once. 

The expression
\begin{babellisting}
concurrent $e$
\end{babellisting}
also evaluates to whatever $e$ evaluates to, again with the exception of dynamic exceptions which are converted to persistent ones. This evaluation will happen concurrently.  
It is guaranteed that $e$ is only evaluated once.

One could think that apart from obvious different performance characteristics, the expressions \babelsrc{lazy $\ e$} and \babelsrc{concurrent $\ e$} are equivalent. This is not so.
If $e$ is a non-terminating expression then, even if  the value of  \babelsrc{concurrent  $\ e$} is never needed during program execution, it might still lead to a non-terminating program execution. In other words, the behaviour of \babelsrc{concurrent $\ e$}  is unspecified for non-terminating $e$.

\section{Lists and Vectors}
For $n \ge 0$, the expression
\begin{babellisting}
[$e_1$, $\ldots$, $e_n$]
\end{babellisting}
denotes a \emph{list} of $n$ elements. 

The expression
\begin{babellisting}
($e_1$, $\ldots$, $e_n$)
\end{babellisting}
denotes a  \emph{vector} of $n$ elements, at least for $n \neq 1$. 
For $n=1$, there is a problem with notation, though, because \babelsrc{($e$)}  is equivalent to $e$. Therefore there is the special notation \babelsrc{($e$,)} for vectors which consist of only one element.

The only difference between lists and vectors is that they have different performance characteristics for the possible operations on them. Lists behave like simply linked lists, and vectors behave like arrays. Note that all data structures in Babel-17 are immutable. Apart from performance characteristics, anywhere you can use a list, you can use a vector, and vice versa. 

Another way of writing down lists is via the right-associative \babelsrc{::} constructor:
\begin{babellisting}
$h$::$t$
\end{babellisting}
Here $h$ denotes the \emph{head} of the list and $t$ its \emph{tail}. Actually, note that the expression \babelsrc{[$e_1$, $\ldots$, $e_n$]} is just syntactic sugar for the expression
\begin{babellisting}
$e_1$::$e_2$::$\ldots$::$e_n$::[]
\end{babellisting}
Dynamic exceptions cannot be part of a list but are propagated:
\begin{babelcode}
\begin{tabular}{rcll}
(\metababel{DynamicException $v$})::$t$ & $\leadsto$ & \metababel{DynamicException $v$}&\\
$h$::(\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}& {\rm where $h$ is non-exceptional}\\
\end{tabular}\\
\end{babelcode}
Note that in cases where the tail $t$ is not a list, we identify \babelsrc{$h$::$t$} with  \babelsrc{$h$::$t$::[]} .

\section{CExprs}
A \metababel{CExpr} is a constructor $c$ together with a parameter $p$, written $c$ $p$. It is allowed to leave out the parameter $p$, which then defaults to \babelsrc{()}. For example,  \babelsrc{HELLO} is equivalent to \babelsrc{HELLO ()}. A constructor $c$ cannot have a dynamic exception as its parameter, therefore we have:
\begin{babelcode}
\begin{tabular}{rcll}
$c$ (\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}&\\
\end{tabular}\\
\end{babelcode}

\section{Pattern Matching}
Maybe the most powerful tool in Babel-17 is pattern matching. You use it in several places, most prominently in the \babelsrc{match} expression which has the following syntax:
\begin{babellisting}
match $e$ 
  case $p_1$ => $b_1$
  $\vdots$
  case $p_n$ => $b_n$
end  
\end{babellisting}
Given a value $e$, Babel-17 tries to match it to the patterns $p_1$, $p_2$, $\ldots$ and so on sequentially in that order. If $p_i$ is the first pattern to match, then the result of \babelsrc{match} 
is given by the block expression $b_i$. If none of the pattern matches then there are two possible outcomes:
\begin{enumerate}
\item If $e$ is a dynamic exception, then the value of the match is just $e$.
\item Otherwise the result is a dynamic exception with parameter \babelsrc{NoMatch $\ e$}.
\end{enumerate}
A few of the pattern constructs are capable of raising dynamic exceptions because they incorporate arbitrary value expressions. When during a pattern match such an exception occurs, then the entire match is aborted and the dynamic exception is returned as the result of the \babelsrc{match}-expression. Furthermore note that persistent exceptions in $e$ or any of the patterns also lead to a dynamic exception if the value of the persistent exception is forced for pattern matching.

So what does a pattern look like? Table~\ref{table:patterns} lists all ways of building a pattern.
\begin{table}
\caption{Pattern Constructs in Babel-17}
\begin{tabular}{c|l}
\textbf{Syntax} & \textbf{General Description}\\\hline
\babelsrc{_} & \patterndescr{the underscore symbol matches anything but a dynamic exception}\\\hline
\babelsrc{$x$} & \patterndescr{an identifier $x$ matches anything but a dynamic exception and binds the matched expression to $x$}\\\hline
\babelsrc{($x\ $ as $\ p$)} & \patterndescr{matches $p$, and binds the successfully matched value to $x$; the match fails if $p$ does not match or if the matched value is a dynamic exception}\\\hline
\babelsrc{$z$} & \patterndescr{a number $z$, like \babelsrc{0} or \babelsrc{42} or \babelsrc{-10} or 
\babelsrc{infinity} or \babelsrc{-infinity} , matches just that number $z$}\\\hline
\babelsrc{$c\ $ $p$} & \patterndescr{matches a \metababel{CExpr} with constructor $c$ if the parameter of the \metababel{CExpr} matches $p$}\\\hline
\babelsrc{$s$} & \patterndescr{a string $s$, like \babelsrc{"hello"}, matches just that string $s$}\\\hline
\babelsrc{[$p_1$, $\ \ldots\ $, $\ p_n$]} &  \patterndescr{matches a list/vector consisting of $n \ge 0$ elements, such that element $e_i$ of the list is matched by pattern $p_i$}\\\hline
\babelsrc{($p_1$, $\ \ldots\ $, $\ p_n$)} &  \patterndescr{matches a vector/list consisting of $n=0$ or $n \ge 2$ elements, such that element $e_i$ of the list is matched by pattern $p_i$}\\\hline
\babelsrc{($p$)} & \patterndescr{same as $p$} \\\hline
\babelsrc{[$p_1$, $\ \ldots\ $, $\ p_n$, $\ \delta$]} &  \patterndescr{matches a list/vector consisting of at least $n \ge 1$ elements, such that the first $n$ elements $e_i$ of the list/vector are matched by the patterns $p_i$}\\\hline
\babelsrc{($p_1$, $\ \ldots\ $, $\ p_n$, $\ \delta$)} &  \patterndescr{matches a vector/list consisting of at least $n \ge 1$ elements, such that the first $n$ elements $e_i$ of the vector/list are matched by the patterns $p_i$}\\\hline
\babelsrc{($p$, )} &  \patterndescr{matches a vector/list consisting of a single element that matches the pattern $p$.} \\\hline
\babelsrc{($h$::$t$)} & \patterndescr{matches a non-empty list/vector such that $h$ matches the head of the list/vector and $t$ its tail}\\\hline
\babelsrc{($p\ $ if $\ e$)} & \patterndescr{matches $p$, but only if $e$ evaluates to \babelsrc{true}; identifiers bound in $p$ can be used in $e$}\\\hline
\babelsrc{(val $\ e$)} & \patterndescr{matches any value which is equivalent to $e$}\\\hline
\babelsrc{($f\ $ ? $\ p$)} & \patterndescr{here $f$ is a function; $f$ is applied to the value to be matched; the match succeeds if the result of the application is \babelsrc{(Some $\ r$)} and $p$ matches $r$, and fails if the result is  \babelsrc{None}; otherwise the dynamic exception \babelsrc{TypeError} is thrown} \\\hline
\babelsrc{($d\ $ ? $\ p$)} & \patterndescr{here $d$ is a not a function and non-exceptional;   short for \babelsrc{((v => v.deconstruct $\ d$) ? $\ p$)}}\\\hline
\babelsrc{($e\ $ ?)} & \patterndescr{similar as the two patterns above but tests for \babelsrc{true / false} instead}\\\hline
\babelsrc{\{$p_1$,$\ \ldots\ $,$\ p_n$\}} & \patterndescr{see section~\ref{sec-setmap-patterns}} \\\hline
\babelsrc{\{$p_1$,$\ \ldots\ $,$\ p_n\ $, $\ \delta$\}} & \patterndescr{see section~\ref{sec-setmap-patterns}} \\\hline
\babelsrc{\{$q_1\ $ -> $\ p_1$,$\ \ldots\ $,$\ q_n\ $ -> $\ p_n$\}} & \patterndescr{see section~\ref{sec-setmap-patterns}}\\\hline
\babelsrc{\{$q_1\ $ -> $\ p_1$,$\ \ldots\ $,$\ q_n\ $ -> $\ p_n$, $\ \delta$\}} & \patterndescr{see section~\ref{sec-setmap-patterns}}\\\hline
\babelsrc{\{->\}} & \patterndescr{matches the empty map}\\\hline
\babelsrc{\{$m_1\ $ = $\ p_1$,$\ \ldots\ $,$\ m_n\ $ = $\ p_n$\}} & \patterndescr{matches an object that has exactly the messages $m_1$,.., $m_n$}\\\hline
\babelsrc{\{$m_1\ $ = $\ p_1$,$\ \ldots\ $,$\ m_n\ $ = $\ p_n$, $\ \delta$\}} & \patterndescr{matches an object that has the messages $m_1$,.., $m_n$}\\\hline
\babelsrc{nil} & \patterndescr{matches the empty object}\\\hline
\babelsrc{exception} $p$ & \patterndescr{matches any exception such that its parameter matches $p$}
\end{tabular}
\label{table:patterns}
\end{table}

In this table of pattern constructions we use the $\delta$-pattern $\delta$. This pattern stands for "the rest of the collection under consideration" and can be constructed by the following rules:
\begin{enumerate}
\item The ellipsis \babelsrc{...} is a $\delta$-pattern that matches any collection.
\item If $\delta$ is a $\delta$-pattern, and $x$ an identifier, then \babelsrc{($x\ $ as $\ \delta$)} is a $\delta$-pattern.
\item If $\delta$ is a $\delta$-pattern, and $e$ an expression, then \babelsrc{($\delta\ $ if $\ e$)} is a $\delta$-pattern.
\item If $\delta$ is a $\delta$-pattern, and $e$ an expression, then \babelsrc{($e\ $ ? $\ \delta$)} is a $\delta$-pattern.\end{enumerate}

Note that pattern matching does not distinguish between vectors and lists. A pattern that looks like a vector can match a list, and vice versa.

\section{Non-Determinism in Babel-17}

One source of non-determinism in Babel-17 is \emph{probabilistic} non-determism. The expression
\begin{babellisting}
random $n$
\end{babellisting}
returns for an integer $n > 0$ a number between $0$ and $n-1$ such that each number between $0$ and $n-1$ has equal chance of being returned. If $n$ is a dynamic exception, then this exception is propagated, if $n$ is a non-exceptional value that is not an integer $> 0$ then the result is an exception with parameter \babelsrc{InvalidArgument $\ n$}.

The other source of non-determinism is choice. The expression
\begin{babellisting}
choose $l$
\end{babellisting}
takes a non-empty collection $l$ and returns a member of the collection. The choice operator makes it possible to optimize evaluation in certain cases. For example, in 
\begin{babellisting}
choose (concurrent a, concurrent b)
\end{babellisting}
the evaluator could choose the member that evaluates quicker.

\section{Block Expressions}
So far we have only looked at expressions. We briefly mentioned the term \emph{block expressions} in the description of the \babelsrc{match} function, though.  We will now introduce and explain block expressions.

Block expressions can be used in several places as defined by the Babel-17 grammar. For example, they can be used in a \babelsrc{match} expression to define the value that corresponds to a certain case. But block expressions can really be used just everywhere where a normal expression is allowed: 
\begin{babellisting}
begin
  $b$
end
\end{babellisting}
is a normal expression where $b$ is a block expression. A block expression has the form
\begin{babellisting}
$s_1$
$\vdots$
$s_n$
$e$
\end{babellisting}
where the $s_i$ are statements and $e$ is the return expression of the block (a return expression is just a normal expression). In a block expression newlines can be used to separate the statements and the return expression from each other. The other means of separation are semicolons. Later on we will see how block expressions can be used to imitate imperative programming; on those occasions there will be no return expression $e$ but only statements.

Statements are Babel-17's primary tool for introducing identifiers. There are several kinds of statements. Two of them will be introduced in this section.

First, there is the \babelsrc{val}-statement which has the following syntax:
\begin{babellisting}
val $p$ = $e$
\end{babellisting}
Here $p$ is a pattern and $e$ is an expression. Its meaning is that $e$ gets evaluated and then is matched to $p$. If the match is successful then all identifiers bound by the match can be used in later statements and in the return expression of the block expression. Otherwise, some kind of dynamic exception must have happened which then becomes the value of the entire block expression. 

Second, there is the \babelsrc{def}-statement which obeys the following syntax for defining the identifier $id$:
\begin{babellisting}
def $id$ $arg$ = $e$
\end{babellisting}
The $arg$ part is optional. If $arg$ is present, then it must be a pattern. Let us call those definitions where $arg$ is present a \emph{function definition}, and those definitions where $arg$ is not present a \emph{simple definition}.  

Per block expression and identifier $id$ there can be either a single simple definition, or there can be several function definitions. If there are multiple function definitions for the same identifier, then they must appear sequentially in the block expression, without any other statements interrupting the sequence.

The defining expressions in  \babelsrc{def}-statements can recursively refer to the other identifiers defined by  \babelsrc{def}-statements in the same block expression. This is the main difference between definitions via \babelsrc{def} and definitions via \babelsrc{val}. Only those \babelsrc{val}-identifiers are in scope that have been defined \emph{previously}. Table~\ref{table:legaldef} exemplifies this rule.
\begin{table}
\caption{Legal and illegal definitions}
\begin{tabular}{c@{\hspace{1cm}}c@{\hspace{1cm}}c@{\hspace{1cm}}c}
\begin{babellisting}
val x = y       
val y = 0
\end{babellisting} &
\begin{babellisting}
def x = y       
val y = 0
\end{babellisting} &
\begin{babellisting}
val x = y       
def y = 0
\end{babellisting} &
\begin{babellisting}
def x = y       
def y = 0
\end{babellisting} \\[0.5cm]
\emph{illegal} &
\emph{illegal} &
\emph{legal} &
\emph{legal} 
\end{tabular}
\label{table:legaldef}
\end{table}

Let us assume that  a block expression contains multiple function definitions for the same identifier \babelsrc{f}:
\begin{babellisting}
def f $p_1$ = $e_1$ 
   $\vdots$
def f $p_n$ = $e_n$ 
\end{babellisting}
Then this is equivalent to 
\begin{babellisting}
def f x = 
  match x
    case $p_1$ => $e_1$
      $\vdots$
    case $p_n$ => $e_n$ 
  end
\end{babellisting}
where \babelsrc{x} is fresh for the $p_i$ and $e_i$.

While only one simple definition per block and identifier is allowed, it is ok to have multiple \babelsrc{val}-statements for the same identifier in one block expression, for example like that:
\begin{babellisting}
val x = 1
val x = (x, x)
x
\end{babellisting}
The above block expression evaluates to \babelsrc{(1,1)}; later \babelsrc{val}-definitions overshadow earlier ones.
But note that neither
\begin{babellisting}
val x = 1
def x = 1
\end{babellisting}
nor
\begin{babellisting}
def x = 1
val x = 1
\end{babellisting}
are legal.

Another difference between \babelsrc{val} and \babelsrc{def} is observed by the effects of non-determinism:
\begin{babellisting}
val x = random 2
(x, x)
\end{babellisting}
will evaluate either to \babelsrc{(0, 0)} or to \babelsrc{(1, 1)}. But 
\begin{babellisting}
def x = random 2
(x, x)
\end{babellisting}
can additionally also evaluate to \babelsrc{(0, 1)} or to \babelsrc{(1, 0)}. The reason for this is that above code snippet is syntactic sugar for:
\begin{babellisting}
def x () = random 2
(x(), x())
\end{babellisting}

\emph{ToDo: need to explain more about order of vals and defs, especially that vals cannot reference later vals, even not indirectly via defs. This will also clean up the parts about module and object initialization.}

\section{Anonymous Functions}
So far we have seen how to define named functions in Babel-17. Sometimes we do not need a name for a certain function, for example when the code that implements this function is actually just as easy to understand as any name for the function. We already have the tools for writing such nameless, or anonymous, functions:
\begin{babellisting}
begin
  def sqr x = x * x 
  sqr
end
\end{babellisting}
is an expression denoting the function that squares its argument. There is a shorter and equivalent way of writing down the above:
\begin{babellisting}
x => x * x
\end{babellisting}
In general, the syntax is
\begin{babellisting}
$p$ => $e$
\end{babellisting}
where $p$ is a pattern and $e$ an expression. The above is equivalent to
\begin{babellisting}
begin
  def f $p$ = $e$ 
  f
end
\end{babellisting}
where \babelsrc{f} is fresh for $p$ and $e$.


There is also a syntax for anonymous functions which allows for several cases:
\begin{babellisting}
(case $p_1$ => $b_1$
    $\vdots$
 case $p_n$ => $b_n$)
\end{babellisting}
is equivalent to 
\begin{babellisting}
begin
  def f $p_1$ = begin $b_1$ end
    $\vdots$
  def f $p_n$ = begin $b_n$ end
  f
end
\end{babellisting}
where $\babelsrc{f}$ is fresh for the $p_i$ and $b_i$.

\section{Objects}
\babelsrc{Object} expressions have the following syntax:
\begin{babellisting}
object 
  $s_1$
  $\vdots$
  $s_n$
end
\end{babellisting}
The $s_i$ are arbitrary statements.  Those $s_i$ that are  \babelsrc{def} statements define the set of messages that the object responds to.

Often you do not want to create objects from scratch but by modifying other already existing objects:
\begin{babellisting}
object + parents
  $s_1$
  $\vdots$
  $s_n$
end
\end{babellisting}
The expression \babelsrc{parents} must evaluate to either a list, a vector or a set. The members of  \babelsrc{parents}
are considered to be the parents of the newly created object, in the order induced by the collection. The idea is that the created object not only understands the messages defined by the $s_i$, but also the messages of the parents. Messages defined via $s_i$ shadow messages of the parents. The messages of an earlier parent shadow the messages of a later one.

The keyword \babelsrc{this} has currently no meaning in Babel-17.

\noindent There is one more way to denote record-like objects:
\begin{babellisting}
{ $m_1$ = $v_1$, $\ldots$, $m_n$ = $v_n$ }
\end{babellisting}
This is equivalent to:
\begin{babellisting}
begin
  val ($w_1$, $\ldots$, $w_n$) = ($v_1$, $\ldots$, $v_n$)
  object
    def $m_1$ = $w_1$
    $\cdots$
    def $m_n$ = $w_n$
  end
end
\end{babellisting}
The empty object is denoted by
\begin{babellisting}
nil
\end{babellisting}
which is equivalent to
\begin{babellisting}
object end
\end{babellisting}


\section{Boolean Operators}

Babel-17 provides the usual boolean operators. They are just syntactic sugar for certain \babelsrc{match} expressions; the exact translations are given in Table~\ref{tab:booleanops}.
\begin{table}
\caption{Boolean Operators}
\begin{tabular}{c|c|c}
\babelsrc{\! a} & \babelsrc{a \& b} &\babelsrc{a | b} \\\hline
 \small
\begin{babellisting}
match a 
  case true => 
    false 
  case false => 
    true
  case _ => 
    exception TypeError
end
\end{babellisting}
 & 
 \small
\begin{babellisting}
match a 
  case true => 
    match b 
      case true => 
        true
      case false => 
        false
      case _ => 
        exception TypeError
    end 
  case false => 
    false
  case _ => 
    exception TypeError
end
\end{babellisting}
 & 
 \small
\begin{babellisting}
match a 
  case false => 
    match b 
      case true => 
        true
      case false => 
        false
      case _ => 
        exception TypeError
    end 
  case true => 
    true
  case _ => 
    exception TypeError
end
\end{babellisting}
\end{tabular}
\label{tab:booleanops}
\end{table}
Babel-17 also has \babelsrc{if}-expressions with the following syntax:
\begin{babellisting}
if $b_1$ then
  $e_1$
elseif $b_2$ then
  $e_2$
  $\vdots$
elseif $b_n$ then
  $e_n$
else
  $e_{n+1}$
end
\end{babellisting}
The \babelsrc{elseif}-branches are  optional. Also, they can be eliminated in the obvious manner via nesting, so that we only need to give the semantics for the expression
\begin{babellisting}
if $b$ then $e_1$ else $e_2$ end
\end{babellisting}
The meaning of above expression is defined to be
\begin{babellisting}
match $b$ 
  case true => $e_1$
  case false => $e_2$
  case _ => exception TypeError 
end
\end{babellisting}

\section{Order}
Babel-17 has a built-in partial order \babelsrc{$\le$}. All other relational operators are defined in terms of this partial order (Table~\ref{tab:relops}).
\begin{table}
\caption{Relational Operators}
\begin{tabular}{c|c}
\textbf{Syntax} & \textbf{Semantics} \\\hline
$a >= b$ & $b <= a$ \\
$a == b$ & $a <= b\ \&\ b <= a$ \\
$a < b$ & $a <= b\ \&\ !(a >= b)$ \\
$a > b$ & $a >= b\ \&\ !(a <= b)$ \\
$a$ $!=$ $b$ & $! (a == b)$ \\
\end{tabular}
\label{tab:relops}
\end{table}
It is possible to chain relational operators like this:
\begin{babellisting}
$a$ <= $b$ <= $c$ > $d$ != $e$ 
\end{babellisting}
Intuitively, the above means 
\begin{babellisting}
$a$ <= $b$ & $b$ <= $c$  & $c$ > $d$  & $d$ != $e$ .
\end{babellisting}
Note that  we always evaluate the operands  of relational operators, even chained ones, only once. For example, the precise semantics of $a <= b <= c <= d <= e$ is 
\begin{babellisting}
begin
  val t = $a$
  val u = $b$
  t <= u &
  begin
    val v = $c$
    u <= v & 
    begin
      val w = $d$
      v <= w & w <= $e$
    end
  end
end
\end{babellisting}
In the above, \babelsrc{t}, \babelsrc{u}, \babelsrc{v} and \babelsrc{w} are supposed to be fresh identifiers.  Also note that if there are operands that are exceptions, then the result of a comparison is a dynamic exception with the same parameter as the first such operand (from left to right).

The partial order is defined by the following laws:
\begin{itemize}
\item  \babelsrc{nil} $< -\infty <  z  < \infty < s <  lv < cexpr < set < map < b$ holds for all
 integers $z$, strings $s$,  lists and vectors $lv$,  constructed expressions $cexpr$, sets $set$, maps $map$ and booleans $b$
 \item booleans are totally ordered and \babelsrc{false} $<$ \babelsrc{true} holds
 \item integers are totally ordered in the obvious way
 \item $-\infty == -\infty$ and $\infty == \infty$ both hold 
 \item strings are totally ordered via lexicographic ordering
\item lists and vectors are partially ordered by the lexicographic ordering 
\item constructed expressions are partially ordered by representing them by the pair consisting of constructor and parameter
\item $f <> g$ holds for all functions $f$ and $g$
\item sets are partially ordered by representing them by sorted lists that consist of the elements of the set
\item maps are partially ordered by representing them by sorted lists that consist of the (key, value) pairs of the map
\item let $U$ consist of all user-defined objects  (i.e., defined via \babelsrc{object}) that cannot receive the message \texttt{representative}; then we have  \babelsrc{nil} $<= u < -\infty$  for all $u \in U$; furthermore $U$ is partially ordered by considering its elements as sorted lists that consist of (message, value) pairs.
\item let $a$ be a user-defined object  (i.e., defined via \babelsrc{object}) that has the message \texttt{representative}; let $ra$ be the result of sending  \texttt{representative} to $a$; then $a <= b$ is defined by $ra <= b$, and $b <= a$ is defined via $b <= ra$ for all $b$.
\end{itemize}

\section{Sets and Maps}
Sets and maps are built into Babel-17. For example, the set consisting of 3, 42 and $\infty$ can be written as
\begin{babellisting}
{42, $\infty$, 3}
\end{babellisting}
Sets are always sorted. The default order is Babel-17's built-in partial order, but it is also possible to create sets that work with arbitrary partial orders; an arbitrary partial order is represented as a function that takes a pair and returns a boolean. Adding or removing an element $e$ from a set $S$ is only well-defined when the elements of $S$ together with $e$ are totally ordered by the partial order of $S$. The same holds for testing if an element is in a set. Table~\ref{tab:setops} shows the most commonly used notation for sets. 
\begin{table}
\caption{Set Operations}
\begin{tabular}{c|c}
$S$ \verb!+! $e$ & \tabparbox{set created by inserting the element $e$  into the set $S$} \\\hline
$S$ \verb!-! $e$ & \tabparbox{set created by removing the element $e$  from the set $S$} \\\hline
$S$ \verb!++! $T$ & \tabparbox{set created by inserting all elements of the set/list $T$  into the set $S$} \\\hline
$S$ \verb!--! $T$ & \tabparbox{set created by removing all elements of the set/list $T$ from the set $S$} \\\hline
$S$ \verb!*! $T$ & \tabparbox{cartesian product of the set $S$ and the set $T$, sorted by lexicographic ordering} \\\hline
$S$ \verb!**! $T$ & \tabparbox{set created by removing all elements from the set $S$ which are not in the set $T$} \\\hline
$S$ $e$ & \tabparbox{tests wether $e$ is an element of $S$}\\\hline
$S / f$ & \tabparbox{set created by applying the function $f$ to the elements of $S$}\\\hline
\babelsrc{$S$.reorder $\ p$} & \tabparbox{set created by reordering $S$ according to the partial order $p$; in case of duplicate elements, the greater of the elements relative to the order of $S$ is kept}
\end{tabular}
\label{tab:setops}
\end{table}

Maps map finitely many keys to values. For example, the map that maps 1 to 2 and 4 to 0 is written as
\begin{babellisting}
{1 -> 2, 4 -> 0}
\end{babellisting}
The empty map is denoted by 
\begin{babellisting}
{->}
\end{babellisting}
Maps also have always a partial order associated with them, by default this is Babel-17's built-in partial order.  Operations on maps are only well-defined if all keys of the map together with all other involved keys are totally ordered by the associated order. Table~\ref{tab:mapops} shows the most commonly used notation for maps.
\begin{table}
\caption{Map Operations}
\begin{tabular}{c|c}
$M$ \verb!+! $(k, v)$ & \tabparbox{map created from the map $M$ by associating $k$ with $v$}\\\hline
$M$ \verb!-! $k$ & \tabparbox{map created from the map $M$ by removing the key $k$}\\\hline
$M$ \verb!++! $N$ &  \tabparbox{map created from the map $M$ by adding the key/value pairs of the map/set/list $N$}\\\hline
$M$ \verb!--! $S$ & \tabparbox{map created from $M$ by removing all keys that are in the set/list/map $S$}\\\hline
$M$ \verb!*! $N$ & \tabparbox{map created by using the partial order of $M$; if $(k_M,v_M)$ is contained in $M$ and 
$(k_N, v_N)$ is contained in $N$ such that $k_M == k_N$, then $(k_M, (v_M, v_N))$ is contained in the new map} \\\hline
$M$ \verb!**! $T$ & \tabparbox{map created by removing all keys from the map $M$ which are not in the set/map $T$} \\\hline
$M$ $k$ & \tabparbox{returns the value $v$ associated with $k$ in $M$, or returns a dynamic exception with parameter \texttt{OutOfDomain} if no such value exists} \\\hline
$M \% f$ & \tabparbox{map created by applying the function $f$ to the values of $M$; $f$ takes a key/value pair and returns a value}\\\hline
$M / f$ & \tabparbox{map created by applying the function $f$ to the values of $M$; $f$ takes a value and returns a value}\\\hline
\babelsrc{$M$.reorder $\ p$} & \tabparbox{map created by reordering $M$ according to the partial order $p$; in case of duplicate keys, the greater of the keys relative to the order of $M$ is kept}
\end{tabular}
\label{tab:mapops}
\end{table}

\section{Patterns for Sets and Maps}\label{sec-setmap-patterns}
\emph{ToDo} 

\section{API and Runtime Environment}
Although we have already provided the specification of many operations for the built-in types of Babel-17, this document does not contain the complete API for all types yet. This API will be provided together with the reference implementation for Babel-17. Here is a quick preview of some of its features:
\begin{itemize}
\item Integers are arbitrary precision and support the usual operations, throwing exceptions in cases which are not well-defined. 
\item Division and modulo of integers are euclidean. 
\item Strings support the usual operations like concatenation; the basic unit is a code point, not a character. Advanced operations like the Unicode collation algorithm are not part of Babel-17 currently, but might be introduced in later versions of Babel-17.
\end{itemize}
This specification also does not contain anything about the runtime environment in which Babel-17 is supposed to run. Depending on the runtime environment, there may be additional libraries available to the programmer. 
The medium term goal is to have Babel-17 running on and interfacing with the following platforms:
\begin{itemize}
\item Java and Android
\item iOS 
\item HTML5 / Javascript 
\end{itemize}

\section{Syntactic Sugar}
One of the goals of Babel-17 is that Babel-17 code is easy to read and understand. I have found that allowing arbitrary user-specific extensions to the syntax of code are definitely not helping to achieve this goal. Nevertheless, a bare minimum of syntactic sugar is necessary to support the most basic conventions known from arithmetic; for example, one should be able to write \texttt{3 + 5} to denote the addition of the integer 3 and the integer 5.

The programmer can use some of this syntactic sugar when defining her own objects. For example, \texttt{3 + 5} is just syntactic sugar for 
\begin{babellisting}
3.plus 5
\end{babellisting} 
Table~\ref{tab:syntacticsugar} lists all syntactic sugar of Babel-17 that is also available to the programmer. 
\begin{table}
\caption{Syntactic Sugar}
\begin{tabular}{c|c}
\textbf{Sugared} & \textbf{Desugared} \\\hline\hline
$a$ \verb!+! $b$ & \babelsrc{$a$.plus_ $\ b$} \\\hline
$a$ \verb!-! $b$ & \babelsrc{$a$.minus_ $\ b$} \\\hline
\verb!-! $a$ & \babelsrc{$a$.uminus_} \\\hline
$a$ \verb!*! $b$ & \babelsrc{$a$.times_  $\ b$} \\\hline
$a$ \verb!/! $b$ & \babelsrc{$a$.quotient_  $\ b$} \\\hline
$a$ \verb!div! $b$ & \babelsrc{$a$.div_  $\ b$} \\\hline
$a$ \verb!mod! $b$ & \babelsrc{$a$.mod_  $\ b$} \\\hline
$a$ \verb+^+ $b$ & \babelsrc{$a$.pow_  $\ b$} \\\hline
$a$ \verb!++! $b$ & \babelsrc{$a$.plus__ $\ b$} \\\hline
$a$ \verb!--! $b$ & \babelsrc{$a$.minus__ $\ b$} \\\hline
$a$ \verb!**! $b$ & \babelsrc{$a$.times__  $\ b$}\\\hline
$a$ \verb!//! $b$ & \babelsrc{$a$.quotient__  $\ b$}\\\hline
$a$ \verb!to! $b$ & \babelsrc{$a$.to_ $\ b$}\\\hline
$a$ \verb!downto! $b$ & \babelsrc{$a$.downto_  $\ b$}\\\hline
$f$ $x$ &  \babelsrc{$f$.apply_  $\ x$}
\end{tabular}
\label{tab:syntacticsugar}
\end{table}
The availability of syntactic sugar for function application means that you can let your own objects behave as if they were functions. 

\section{Memoization}
Babel-17 supports \emph{memoization}. 
In those places where \babelsrc{def}-statements can be used, \babelsrc{memoize}-statements can be used, also. A \babelsrc{memoize}-statement must always refer to \babelsrc{def}-statements in the same scope. Babel-17 differentiates two kinds of memoization, \emph{strong} and \emph{weak}. A \babelsrc{memoize}-statement has the following syntax:
\begin{babellisting}
memoize $\metababel{ref}_1 \hdots \metababel{ref}_n$
\end{babellisting}
The $\metababel{ref}_i$ are either of the form $\metababel{id}$ to indicate strong memoization, or of the form $(\metababel{id})$ to signal weak memoization. In both cases $\metababel{id}$ refers to the \babelsrc{def}-statement being memoized. As an example, here is the definition of the weakly memoized fibonacci-sequence:
\begin{babellisting}
memoize (fib)
def fib 0 = 0
def fib 1 = 1
def fib n = fib (n-1) + fib (n-2)
\end{babellisting}
The difference between weak and strong memoization is that strong memoization guarantees that the memoized function will not be executed twice for the same argument; weak memoization does not make this guarantee, so that garbage collection can reclaim all or part of the memoization cache when it needs to. Note that all arguments to the same memoized function must be totally ordered by the built-in partial order.

\section{Linear Scope}
We extend now the syntax of \babelsrc{val}-statements such that it is actually legal to leave out the keyword \babelsrc{val} if all variables defined by it have already been defined  previously in its surrounding \emph{linear scope}. The following two expressions are equivalent:
\begin{center}
\begin{tabular}{ccc}
\begin{babellisting}
begin
  val x = $a$ 
  val y = $b$
  val x = $c$
  $d$
end
\end{babellisting}
& \hspace{2cm} &
\begin{babellisting}
begin
  val x = $a$ 
  val y = $b$
  x = $c$
  $d$
end
\end{babellisting}
\end{tabular}
\end{center}
Furthermore, \babelsrc{begin $\ \hdots\ $ end} can not only be used as an expression, but also as a statement; the following expressions exemplify nested  \babelsrc{begin $\ \hdots\ $ end} statements:
\begin{center}
\begin{tabular}{ccccc}
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    val y = 4 * x
  end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    y = 4 * x
  end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    val y = 0
    y = 4 * x
  end
  (x, y)
end
\end{babellisting}\\\hline
evaluates to $(1, 2)$ & &
evaluates to $(1, 12)$ & &
evaluates to $(1, 2)$ \\[0.5cm]
\end{tabular}
\end{center}
The above examples show that the effect of dropping the \babelsrc{val} in a \babelsrc{val} statement is that the binding of an identifier becomes visible at that level within the linear scope where it has last been introduced via a \babelsrc{val} statement that includes the \babelsrc{val} keyword or via a pattern match in a \babelsrc{match} or \babelsrc{def}.

The linear scope of a statement is defined to be the block expression $b$ that directly contains the statement, together with the linear scope of the expression or statement that contains $b$. 
The linear scope of an expression $e$ is only defined when $e$ is a \emph{control expression} that appears in another \babelsrc{val} statement of the form
\begin{babellisting}
val $\metababel{pat}$ = $e$
\end{babellisting}
or
\begin{babellisting}
$\metababel{pat}$ = $e$
\end{babellisting}
Then the linear scope of $e$ is defined as the linear scope of that \babelsrc{val} statement.
These are all \emph{control expressions} of Babel-17:
\begin{itemize}
\item \babelsrc{begin ... end}
\item \babelsrc{if ... end}
\item \babelsrc{match ... end}
\item \babelsrc{for ... end}
\item \babelsrc{while ... end}
\end{itemize}
The last two control expressions are loops and explained in the next section.

Here are three example code snippets that illustrate linear scope:
\begin{center}
\begin{tabular}{ccccc}
\begin{babellisting}
begin
  val x = 1
  val y = 
    begin 
      x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1
  val y = 3 *
    begin 
      x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1
  val y = 3 *
    begin 
      val x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}\\\hline
evaluates to $(2, 4)$ & &
illegal & &
evaluates to $(1, 12)$ \\[0.5cm]
\end{tabular}
\end{center}

Just as  the \babelsrc{begin ... end} expression may be used as a statement, 
you can also use all other control expressions as statements, for example:
\begin{babellisting}
begin
  val x = random 2
  if x == 0 then
    x = 100
  else
    x = 200
  end
  x + x
end
\end{babellisting}
This expression will evaluate either to $200$ or to $400$.

For \babelsrc{if}-statements the \babelsrc{else}-branch is optional, and \babelsrc{match}-statements do not throw a \babelsrc{NoMatch} exception if none of the patterns matches. 

\section{Yield}
Control expressions always return a value. With the help of the \babelsrc{yield} statement and, optionally, \emph{collector annotations}, the programmer has flexible control about how this value is computed. The syntax of a \babelsrc{yield} statement is simply
\begin{babellisting}
yield $e$
\end{babellisting} 
where $e$ is an arbitrary expression. The semantics is that the value of the control expression is the collection of all the values that have been issued via \babelsrc{yield}. For example, the expression
\begin{babellisting}
begin
  yield 1
  val x = 2
  yield x*x
  yield 3
  10
end
\end{babellisting}
evaluates to \texttt{(1, 4, 3, 10)}. Note how the normal return value of \babelsrc{begin ... end} just counts as an additional \babelsrc{yield}. 

By default, all yielded values are collected in a list which collapses in case of only a single element. The programmer might want to deviate from this default and collect the yielded values differently, for example to get rid of the collapsing behavior. \emph{Collector annotations} allow her to do just that. A collector annotation has the following syntax:
\begin{babellisting}
with $c$ : $e$
\end{babellisting}
where $c$ is a \emph{collector} and $e$ is a control expression. A collector is any object that 
\begin{itemize}
\item responds to the message \verb+collector_close+,
\item and responds to the message \verb+collector_add+ $x$ with another collector.
\end{itemize}
Lists, sets and maps are built-in collectors which the programmer can use out-of-the-box; apart from that she can implement her own collectors, of course.

Here is an example where we use a set as a collector:
\begin{babellisting}
with {4} : begin
  yield 1
  yield 2
  yield 1
  10
end
\end{babellisting}
Above expression evaluates to \babelsrc{\{1, 2, 4, 10\}}.

\section{Loops}
Unlike the other control expressions, \emph{loops} become useful only in combination with \emph{linear scope} and \babelsrc{yield}. 

This is the syntax for the \babelsrc{while}-loop:
\begin{babellisting}
while $c$ do
  $b$
end
\end{babellisting}
Here $c$ must evaluate to a boolean and $b$ is a control block. For example, here is how you could code the euclidean algorithm for calculating the greatest common divisor using \babelsrc{while}:
\begin{babellisting}
def gcd (a,b) = begin
  while b != 0 do
    (a, b) = (b, a mod b)
  end
  a
end
\end{babellisting}

There is also the \babelsrc{for}-loop. It has the following syntax:
\begin{babellisting}
for $p$ in $C$ do
  $b$
end
\end{babellisting}
In the above $p$ is a pattern, $C$ is a \emph{collection} $C$, and $b$ is a control block.
The idea is that above expression iterates through those elements of the \emph{collection} $C$ 
which match $p$; for each successfully matched element, $b$ is executed. 

An object $C$ is a collection if it handles the message \texttt{iterate}
\begin{itemize}
\item by returning \texttt{()} if it represents the empty collection,
\item by returning \texttt{($e$, $C'$)} such that $C'$ is also a collection otherwise.
\end{itemize}

Here is an example of a simple \babelsrc{for}-loop expression:
\begin{babellisting}
begin
  val s = [10, (5, 8), 7, (3,5)]
  with {->} : for (a,b) in s do
    yield (b,a)
  end
end
\end{babellisting}
evaluates to \babelsrc{\{8 -> 5, 5 -> 3\}}.

Using \babelsrc{for}-loops it is possible to formulate all of those \emph{fold}-related functionals known from functional programming in a way which is easier to parse for most people. 

\end{document}  