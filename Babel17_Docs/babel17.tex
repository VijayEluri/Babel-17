\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{listings}
\usepackage{url}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Syntax and Semantics of Babel-17, v0.21 (Draft)}
\author{Steven Obua}
\date{\today}                                          
\newcommand{\metababel}[1] {\textsl{#1}}
\newcommand{\tabparbox}[1] {\parbox{12cm}{

\vspace{0.1cm}
#1
\vspace{0.1cm}
}}
\newcommand{\patterndescr}[1] {\parbox{9cm}{
\small
\vspace{0.1cm}
#1
\vspace{0.1cm}
}}
%\newcommand{\babelsrc}[1] {\texttt{#1}}
\newenvironment{babelcode}[0]{\begin{center}\tt}{\end{center}}

\lstdefinelanguage{babellanguage} 
{morekeywords={lazy, concurrent, force, match, case, exception, begin, end, random, choose,force,true, false, infinity, val, def, this, object,if,then,else,elseif,memoize,for,in,yield,while,do,with,nil, div, mod},
sensitive=true, 
morecomment=[l]{//}, 
morecomment=[s]{/*}{*/}, 
morestring=[b]", 
} 

\lstset{language=babellanguage,mathescape=true,float, xleftmargin=1.5cm,columns=flexible}

\lstnewenvironment{babellisting} 
{\small} 
{} 

\newcommand{\babelsrc}[1] {\lstinline!#1!}


%\newenvironment{babellisting} [0]{\begin{center}\begin{babellistingfree}}{\end{babellistingfree}%\%end{center}}

%lstset{language=babellanguage,mathescape=true}\begin{lstlisting}}{\end{lstlisting}\end{center}}

 
\begin{document}

%\begin{abstract}
%Babel-17 is an evolving new programming language. In this paper I present Babel-17 v0.2. 
%\end{abstract}


\maketitle

\tableofcontents


\section{Introduction}
The first question that someone who creates a new programming language will  hear from others inevitably is: Why another programming language? Are there not already enough programming languages out there that you can pick from?

I always wanted a programming language 
\begin{itemize}
\item in which I can express myself compactly and without jumping through too many hoops, 
\item that is easy to understand and to learn,
\item in which purely functional programming is the default and not the exception,
\item that supports exceptions,
\item that has pattern matching,
\item that has built-in support for laziness and concurrency,
\item that has built-in support for purely functional lists, vectors, sets and maps,
\item that seamlessly marries structured programming constructs like loops with purely functional programming,
\item that supports objects, modules and data encapsulation,
\item that has mature implementations for all major modern computing platforms and can (and should!) be used for real-world programming,
\item that has a simple mechanized formal semantics,
\item that is beautiful.
\end{itemize}
There is no such language out there. Therefore I decided to create one. When Babel-17 will have reached v1.0 then the above goals will have been achieved. The version described in this document is Babel-17 v0.21, so there is still some distance to go. 

Babel-17 is not a radically new or revolutionary programming language. It picks those raisins I like out of languages like Standard ML, Scala, Alice ML, Java, Javascript, Erlang, Haskell, Lisp, Clojure and Mathematica, and tries to evolve them into a beautiful new design. 

Babel-17 is a functional language. It is not a pure functional language because it contains sources of non-determinism like the ability to pick one of two values randomly. If you take these sources of non-determinism out of the language (there are currently only two such sources, \babelsrc{choose}\ and \babelsrc{random}), it becomes pure. 

In Babel-17, every value has a type. These types are not checked statically, but only dynamically. 

Babel-17 is also object-oriented in that many aspects of Babel-17 can be explained in terms of sending messages to objects. 

The default evaluation order of Babel-17 is strict. But optional laziness is built into the heart of Babel-17, also, and so is concurrency. 

Babel-17 has pattern matching and exception handling. Both are carefully integrated with each other and with the laziness and concurrency capabilities of Babel-17.

Furthermore, Babel-17 establishes the paradigm of \emph{purely functional structured programming}  via the notion of linear scope.

In this document  I specify Babel-17 in a mostly informal style: formal notation is sometimes used when it supports clarity.

\section{Reference Implementation and Bug Parade}

At \url{www.babel-17.com} you will find a reference implementation of Babel-17 v0.21 that fully supports the language as described in this document. There you will also find a Netbeans plugin that has syntax and error-highlighting for Babel-17 programs. As you find your way through this document, it might be helpful to directly try out Babel-17 in Netbeans to see if the interpreter behaves as you would guess from this spec. If you find implausible behavior, email your findings to \texttt{bugparade@babel-17.com}. Each proper bug will be listed together with your name (unless you don't wish so; then don't give your name in the email; it's also OK not to give your real name but an alias) and date of your discovery forever at \texttt{bugparade.babel-17.com}. You can also provide a link to your blog or whatever. 

\section{Lexical Matters}
Babel-17 source code is always written UTF-8 encoded. If it ain't UTF-8, it ain't Babel-17. 

Constructors are alphanumeric strings which can also contain underscores, and which must start with a capital letter. 
Identifiers are alphanumeric strings which can also contain underscores, and which must start with a non-capital letter.
The distinction between two constructors or two identifiers is not sensitive to capitalization.

These are the keywords of Babel-17:
\begin{center}
\tt
\begin{tabular}{cccccccc}
begin & end & object & with & if & then & else & elseif \\
while &  for & do & choose & random & yield & match & case \\
as & val & def & in & exception & lazy & concurrent & memoize \\
to & downto & true & false & nil & infinity &  force & this
\end{tabular}
\end{center}
Note that keywords are written always in lower case. For example, {\tt bEGIN} is not a legal keyword, but it also isn't an identifier (because of case insensitivity). Also note that {\tt Begin} and {\tt BEGIN} denote the same legal constructor. When we talk about identifiers in the rest of the paper, we always mean identifiers which are not keywords.

You can write down decimal, hexadecimal, binary and octal numbers in Babel-17. The following notations all denote the same number:
\begin{center}
\tt
\begin{tabular}{cccc}
15 & 0xF & 0b1111 &  0o17
\end{tabular}
\end{center}
Babel-17 also knows the number \babelsrc{infinity}.

Strings start and end with a quotation mark. Between the quotation mark, any valid UTF-8 string is allowed that does not contain newline, backslash or quotation mark characters, for example:
\begin{center}
\begin{tabular}{cccc}
\verb+"hello world"+ & \verb+"$1, 2%"+ & \verb+"1 <= 4! <= 5^2"+
\end{tabular}
\end{center}
Newline, backslash and quotation mark characters can be written down in escaped form. Actually, any unicode character can be written down in its escaped form via the hexadecimal value of its codepoint: 
\begin{center}
\begin{tabular}{r|l}
String consisting only of a quotation mark & \verb+"\""+\\\hline
String consisting only of a backslash & \verb+"\\"+ \\\hline
String consisting only of a line feed & \verb+"\n"+ \\\hline
String consisting only of a carriage return & \verb+"\r"+ \\\hline
String consisting only of line feed via 16-bit escaping & \verb+"\u000A"+ \\\hline
String consisting only of line feed via 32-bit escaping & \verb+"\U0000000A"+
\end{tabular}
\end{center}

Comments in Babel-17 are written between matching pairs of \verb+/*+ and \verb+*/+ and can span several lines. Currently, comments cannot be nested.

Finally, here are all ASCII special symbols that can occur in a Babel-17 program:
\newcommand{\mapcurlyleft}{\{|}
\begin{center}
\tt
\begin{tabular}{ccccccccccccc}
\verb+=+ & \verb+==+ & \verb+!=+ & \verb+<+ & \verb+<=+ & \verb+>+& \verb+>=+  &
\verb-+- & \verb+-+ & \verb+*+ & \verb+/+ & \verb+^+ & \verb+;+  \\
\verb-|- & \verb+&+ & \verb+!+ & \verb-++- & \verb+--+& \verb+**+  &
\verb-//- & \verb+,+ & \verb+::+ & \verb+->+ & \verb+=>+& \verb+?+  & \verb+...+  \\
\verb-(- & \verb+)+ & \verb+[+ & \verb+]+ & \verb+{+& \verb+}+  & \verb+.+ &   &
& & & 
\end{tabular}
\end{center}
Table~\ref{table:furthersymbols} lists all other Unicode symbols that have a meaning in Babel-17.
\begin{table}
\caption{Further Unicode Symbols}
\begin{tabular}{c|c|c}
\textbf{Unicode Hex Code} & \textbf{Display} & \textbf{ASCII Equivalent}\\\hline
%\parbox{0cm}{\vspace{0.7cm}}2983 & \texttt{\{\hspace{-0.089cm}∣} & \verb+{|+\\
%2984 & \texttt{∣\hspace{-0.089cm}\}} & \verb+|}+\\
2261 & ≡ & \verb+==+\\
2262 & ≢ & \verb+!=+\\
2264 & ≤ & \verb+<=+\\
2265 &  ≥ & \verb+>=+\\
221E & ∞ & \babelsrc{infinity}\\ 
2227 & ∧ & \verb+&+\\
2228 & ∨ & \verb+|+\\
00AC & ¬ & \verb+!+\\
2237 & :: & \verb+::+\\
2192 & → & \verb+->+\\
21D2 & ⇒ & \verb+=>+\\
2026 & … & \verb+...+\\
\end{tabular}
\label{table:furthersymbols}
\end{table}


\section{Overview of Built-in Types}
Each value in Babel-17 has a unique type. All built-in types are depicted in Table~\ref{table:builtintypes}.
\begin{table}
\caption{Built-in Types of Babel-17}
\begin{tabular}{c|c}
\textbf{Type} & \textbf{Description}\\\hline
\metababel {Integer} & the type of arbitrary size integer numbers\\
\metababel{Infinity} & the type consisting of the values \babelsrc{infinity} and \babelsrc{-infinity}\\
\metababel{Boolean} & the type consisting of the values \babelsrc{true} and \babelsrc{false}\\
\metababel{String} & the type of valid Unicode strings\\
\metababel{List} & the type of lists\\
\metababel{Vector} & the type of vectors / tuples\\
\metababel{Set} & the type of sets \\
\metababel{Map}& the type of maps \\
\metababel{CExpr} & the type of constructed expressions\\
\metababel{Object} & the type of user-defined objects\\
\metababel{Function} & the type of  functions\\
\metababel{PersistentException} & the type of persistent exceptions\\
\metababel{DynamicException} & the type of dynamic exceptions\\
\end{tabular}
\label{table:builtintypes}
\end{table}
There is currently no way to explicitly test the type of a value. There is also currently no way to annotate the type of a variable.
Future versions of Babel-17 will include such capabilities.

\section{Objects and Functions}
All values in Babel-17 are objects. This means that you can send messages to them. Many values in Babel-17 are functions. This means that you can apply them to an argument, yielding another value. Note that for a value to be an object, it does not need to have type \metababel{Object}, and for a value to be a function,  it does not need to have type \metababel{Function}. 

The result of sending message $m$ to object $v$  is written as
\begin{babellisting}
$v$.$m$
\end{babellisting}
Here $m$ is an identifier. The special object \babelsrc{nil}\ does not respond to any message.

The result of applying function $f$ to value $x$ is written as 
\begin{babellisting}
$f$ $x$
\end{babellisting}
Note that $f$ $x$ is equivalent to 
\begin{babellisting}
($f$.apply_) $x$
\end{babellisting}
Therefore any object that responds to the \babelsrc{apply_} message can act as a function.
In the above we could also leave out the brackets because sending messages binds stronger than function application. 

Repeated function application associates to the left, therefore 
\begin{babellisting}
$f$ $x$ $y$ 
\end{babellisting} 
is equivalent to \babelsrc{($f$\ $x$)\ $y$}.

\section{Exceptions}
Exception handling in Babel-17 mimicks exception handling mechanisms like those which can be found in Java or Standard ML, while adhering at the same time to the functional paradigm.

There are two types of exceptions: \metababel{PersistentException} and  \metababel{DynamicException}.
The difference is that a \metababel{PersistentException}  can be treated as part of any data structure, and is passed around just like any other value, while a \metababel{DynamicException} can never be part of a data structure and has special evaluation semantics. 

Exceptions in Babel-17 are not that special at all but mostly just another type of value.  Let us write \metababel{PersistentException $v$} for a \metababel{PersistentException} with parameter $v$,
and  \metababel{DynamicException $v$} for a \metababel{DynamicException} with parameter $v$. 
We also write \metababel{Exception $v$} for an exception with parameter $v$. The parameter $v$ is a \emph{non-exceptional} value; this means that $v$ can be any Babel-17 value except one of type \metababel{DynamicException}. Note that a value of type \metababel{PersistentException} is therefore non-exceptional.

The following deterministic rules govern how exceptions behave with respect to sending of messages, function application, laziness and concurrency:
\begin{babelcode}
\begin{tabular}{rcl}
(\metababel{Exception $v$}).$m$ & $\leadsto$ & \metababel{DynamicException $v$}\\
(\textsl{DynamicException} $v$) $x$ & $\leadsto$ & \metababel{DynamicException $v$}\\
$f$ (\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}  {\rm where $f$ is non-exceptional}\\
(\metababel{PersistentException $v$}) $g$ & $\leadsto$ & \metababel{DynamicException $v$}  {\rm where $g$ is non-exceptional}\\
exception $v$ & $\leadsto$ & \metababel{DynamicException $v$}\\
lazy (\metababel{Exception $v$}) & $\leadsto$ & \metababel{PersistentException $v$}\\
concurrent (\metababel{Exception $v$}) & $\leadsto$ & \metababel{PersistentException $v$}\\
force $v$  & $\leadsto$ & $v$  {\rm for all $v$, including exceptions}
\end{tabular}\\
\end{babelcode}
Exceptions in Babel-17 are created with the expression \babelsrc{exception $\ v$}. Creating exceptions in Babel-17 corresponds to \emph{raising} or \emph{throwing} exceptions in other languages. There is no special construct for catching exceptions in Babel-17. Instead, catching an exception can be done via the \babelsrc{match} expression which will be described later. 

In the next section, we will describe the  \babelsrc{lazy} and \babelsrc{concurrent} expressions of Babel-17. They are the reason why exceptions are divided into dynamic and persistent ones. 

\section{Laziness and Concurrency}
The default evaluation mechanism of Babel-17 is strict. This basically means that the arguments of a function are evaluated before the function is applied to them. Babel-17 has two constructs to change this default behaviour. 

The expression
\begin{babellisting}
lazy $e$
\end{babellisting}
is not evaluated until it is actually needed. When it is needed, it evaluates to whatever $e$ evaluates to, with the exception of dynamic exceptions, which are converted to persistent ones.  

The expression
\begin{babellisting}
concurrent $e$
\end{babellisting}
also evaluates to whatever $e$ evaluates to, again with the exception of dynamic exceptions which are converted to persistent ones. This evaluation will happen concurrently.  

One could think that apart from obvious different performance characteristics, the expressions \babelsrc{lazy $\ e$} and \babelsrc{concurrent $\ e$} are equivalent. This is not so.
If $e$ is a non-terminating expression then, even if  the value of  \babelsrc{concurrent  $\ e$} is never needed during program execution, it might still lead to a non-terminating program execution. In other words, the behaviour of \babelsrc{concurrent $\ e$}  is unspecified for non-terminating $e$.

Sometimes you do not want to proceed until an expression has been completely evaluated so that it does not contain any lazy or concurrent subcomponents any more. In those situations you use the expression
\begin{babellisting}
force $e$
\end{babellisting}
which evaluates to $e$. So semantically, \babelsrc{force} is just the identity function. 

We mentioned before that lazy and concurrent expressions are the reason why exceptions are divided into dynamic and persistent ones. To motivate this, look at the expression
\begin{babellisting}
fst (0, lazy (1 div 0))
\end{babellisting}
Here the function \babelsrc{fst} is supposed to be a function that takes a pair and returns the first element of this pair. So what would above expression evaluate to? Obviously, \babelsrc{fst} does not need to know the value of the second element of the pair as it depends only on the first element, so above expression evaluates just to 0. Now, if \babelsrc{lazy} was semantically just the identity function, then we would have
\begin{babellisting}
0 = fst (0, lazy (1 div 0)) = fst (0, 1 div 0) = fst (0, exception DomainError) 
   = fst (exception DomainError) = exception DomainError
\end{babellisting}
Obviously, $0$ should not be the same as an exception, and therefore \babelsrc{lazy} cannot be the identity function, but converts dynamic exceptions into persistent ones. For a dynamic exception $e$ the equation
\begin{babellisting}
(0, $e$) = $e$
\end{babellisting}
holds. For a persistent exception $e$ this equation does not hold, and therefore the above chain of equalities is broken.

\section{Lists and Vectors}
For $n \ge 0$, the expression
\begin{babellisting}
[$e_1$, $\ldots$, $e_n$]
\end{babellisting}
denotes a \emph{list} of $n$ elements. 

The expression
\begin{babellisting}
($e_1$, $\ldots$, $e_n$)
\end{babellisting}
denotes a  \emph{vector} of $n$ elements, at least for $n \neq 1$. 
For $n=1$, there is a problem with notation, though, because \babelsrc{($e$)}  is equivalent to $e$. Therefore there is the special notation \babelsrc{($e$,)} for vectors which consist of only one element.

The only difference between lists and vectors is that they have different performance characteristics for the possible operations on them. Lists behave like simply linked lists, and vectors behave like arrays. Note that all data structures in Babel-17 are immutable. Apart from performance characteristics, anywhere you can use a list, you can use a vector, and vice versa. 

Another way of writing down lists is via the right-associative \babelsrc{::} constructor:
\begin{babellisting}
$h$::$t$
\end{babellisting}
Here $h$ denotes the \emph{head} of the list and $t$ its \emph{tail}. Actually, note that the expression \babelsrc{[$e_1$, $\ldots$, $e_n$]} is just syntactic sugar for the expression
\begin{babellisting}
$e_1$::$e_2$::$\ldots$::$e_n$::[]
\end{babellisting}
Dynamic exceptions cannot be part of a list but are propagated:
\begin{babelcode}
\begin{tabular}{rcll}
(\metababel{DynamicException $v$})::$t$ & $\leadsto$ & \metababel{DynamicException $v$}&\\
$h$::(\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}& {\rm where $h$ is non-exceptional}\\
\end{tabular}\\
\end{babelcode}
Note that in cases where the tail $t$ is neither a list nor a vector, we identify \babelsrc{$h$::$t$} with  \babelsrc{$h$::$t$::[]} . 

\section{CExprs}
A \metababel{CExpr} is a constructor $c$ together with a parameter $p$, written $c$ $p$. It is allowed to leave out the parameter $p$, which then defaults to \babelsrc{nil}. For example,  \babelsrc{HELLO} is equivalent to \babelsrc{HELLO} \babelsrc{nil}. A constructor $c$ cannot have a dynamic exception as its parameter, therefore we have:
\begin{babelcode}
\begin{tabular}{rcll}
$c$ (\metababel{DynamicException $v$}) & $\leadsto$ & \metababel{DynamicException $v$}&\\
\end{tabular}\\
\end{babelcode}

\section{Pattern Matching}
Maybe the most powerful tool in Babel-17 is pattern matching. You use it in several places, most prominently in the \babelsrc{match} expression which has the following syntax:
\begin{babellisting}
match $e$ 
  case $p_1$ => $b_1$
  $\vdots$
  case $p_n$ => $b_n$
end  
\end{babellisting}
Given a value $e$, Babel-17 tries to match it to the patterns $p_1$, $p_2$, $\ldots$ and so on sequentially in that order. If $p_i$ is the first pattern to match, then the result of \babelsrc{match} 
is given by the block expression $b_i$. If none of the pattern matches then there are two possible outcomes:
\begin{enumerate}
\item If $e$ is a dynamic exception, then the value of the match is just $e$.
\item Otherwise the result is a dynamic exception with parameter \babelsrc{NoMatch}.
\end{enumerate}
A few of the pattern constructs  incorporate arbitrary value expressions. When these expressions raise exceptions, the whole pattern they are contained in is rendered non-matching.

So what does a pattern look like? Table~\ref{table:basicpatterns}  and  Table~\ref{table:collectionpatterns} list all ways of building a pattern.
\begin{table}
\caption{General Patterns}
\begin{tabular}{c|l}
\textbf{Syntax} & \textbf{Description}\\\hline
\babelsrc{_} & \patterndescr{the underscore symbol matches anything but a dynamic exception}\\\hline
\babelsrc{$x$} & \patterndescr{an identifier $x$ matches anything but a dynamic exception and binds the matched expression to $x$}\\\hline
\babelsrc{($x\ $ as $\ p$)} & \patterndescr{matches $p$, and binds the successfully matched value to $x$; the match fails if $p$ does not match or if the matched value is a dynamic exception}\\\hline
\babelsrc{$z$} & \patterndescr{a number $z$, like \babelsrc{0} or \babelsrc{42} or \babelsrc{-10} or 
\babelsrc{infinity} or \babelsrc{-infinity} , matches just that number $z$}\\\hline
\babelsrc{$c\ $ $p$} & \patterndescr{matches a \metababel{CExpr} with constructor $c$ if the parameter of the \metababel{CExpr} matches $p$}\\\hline
\babelsrc{$s$} & \patterndescr{a string $s$, like \babelsrc{"hello"}, matches just that string $s$}\\\hline
\babelsrc{($p$)} & \patterndescr{same as $p$} \\\hline
\babelsrc{($p\ $ if $\ e$)} & \patterndescr{matches any non-exceptional value that matches $p$, but only if $e$ evaluates to \babelsrc{true}; identifiers bound in $p$ can be used in $e$}\\\hline
\babelsrc{(val $\ e$)} & \patterndescr{matches anynon-exceptional  value which is equivalent to $e$}\\\hline
\babelsrc{($f\ $ ? $\ p$)} & \patterndescr{here $f$ is a function; $f$ is applied to the value to be matched; the match succeeds if the result of the application is not an exception amd matches $p$}\\\hline
\babelsrc{($d\ $ ? $\ p$)} & \patterndescr{here $d$ is a not a function and not an exception;   short for \babelsrc{((v => v.deconstruct_ $\ d$) ? $\ p$)}}\\\hline
\babelsrc{($e\ $ ?)} & \patterndescr{short for \babelsrc{($e\ $ ? true)} }\\\hline
\babelsrc{\{$m_1\ $ = $\ p_1$,$\ \ldots\ $,$\ m_n\ $ = $\ p_n$\}} & \patterndescr{matches an object that has exactly the messages $m_1$,.., $m_n$ such that the message values match the given patterns}\\\hline
\babelsrc{\{$m_1\ $ = $\ p_1$,$\ \ldots\ $,$\ m_n\ $ = $\ p_n$, $\ \delta$\}} & \patterndescr{matches an object that has the messages $m_1$,.., $m_n$ such that the message values match the given patterns}\\\hline
\babelsrc{nil} & \patterndescr{matches the empty object}\\\hline
\babelsrc{exception} $p$ & \patterndescr{matches any exception such that its parameter matches $p$}
\end{tabular}
\label{table:basicpatterns}
\end{table}
\begin{table}
\caption{Collection Patterns}
\begin{tabular}{c|l}
\textbf{Syntax} & \textbf{Description}\\\hline
\babelsrc{[$p_1$, $\ \ldots\ $, $\ p_n$]} &  \patterndescr{matches a list/vector consisting of $n \ge 0$ elements, such that element $e_i$ of the list is matched by pattern $p_i$}\\\hline
\babelsrc{($p_1$, $\ \ldots\ $, $\ p_n$)} &  \patterndescr{matches a vector/list consisting of $n=0$ or $n \ge 2$ elements, such that element $e_i$ of the list is matched by pattern $p_i$}\\\hline
\babelsrc{[$p_1$, $\ \ldots\ $, $\ p_n$, $\ \delta$]} &  \patterndescr{matches a list/vector consisting of at least $n \ge 1$ elements, such that the first $n$ elements $e_i$ of the list/vector are matched by the patterns $p_i$}\\\hline
\babelsrc{($p_1$, $\ \ldots\ $, $\ p_n$, $\ \delta$)} &  \patterndescr{matches a vector/list consisting of at least $n \ge 1$ elements, such that the first $n$ elements $e_i$ of the vector/list are matched by the patterns $p_i$}\\\hline
\babelsrc{($p$, )} &  \patterndescr{matches a vector/list consisting of a single element that matches the pattern $p$.} \\\hline
\babelsrc{($h$::$t$)} & \patterndescr{matches a non-empty list/vector such that $h$ matches the head of the list/vector and $t$ its tail}\\\hline
\babelsrc{\{$p_1$,$\ \ldots\ $,$\ p_n$\}} & \patterndescr{see section~\ref{sec:setsandmaps}} \\\hline
\babelsrc{\{$p_1$,$\ \ldots\ $,$\ p_n\ $, $\ \delta$\}} & \patterndescr{see section~\ref{sec:setsandmaps}} \\\hline
\babelsrc{\{$q_1\ $ -> $\ p_1$,$\ \ldots\ $,$\ q_n\ $ -> $\ p_n$\}} & \patterndescr{see section~\ref{sec:setsandmaps}}\\\hline
\babelsrc{\{$q_1\ $ -> $\ p_1$,$\ \ldots\ $,$\ q_n\ $ -> $\ p_n$, $\ \delta$\}} & \patterndescr{see section~\ref{sec:setsandmaps}}\\\hline
\babelsrc{\{->\}} & \patterndescr{see section~\ref{sec:setsandmaps}}\\\hline
\babelsrc{\(for $\ p_1$,$\ \ldots\ $, $\ p_n\ $end\)} & \patterndescr{see section~\ref{sec:loops}}\\\hline
\babelsrc{\(for $\ p_1$,$\ \ldots\ $, $\ p_n$, $\ \delta\ $end\)} & \patterndescr{see section~\ref{sec:loops}}
\end{tabular}
\label{table:collectionpatterns}
\end{table}

In this table of pattern constructions we use the $\delta$-pattern $\delta$. This pattern stands for "the rest of the entity under consideration" and can be constructed by the following rules:
\begin{enumerate}
\item The ellipsis \babelsrc{...} is a $\delta$-pattern that matches any rest.
\item If $\delta$ is a $\delta$-pattern, and $x$ an identifier, then \babelsrc{($x\ $ as $\ \delta$)} is a $\delta$-pattern.
\item If $\delta$ is a $\delta$-pattern, and $e$ an expression, then \babelsrc{($\delta\ $ if $\ e$)} is a $\delta$-pattern.
\end{enumerate}

Note that pattern matching does not distinguish between vectors and lists. A pattern that looks like a vector can match a list, and vice versa.

\section{Non-Determinism in Babel-17}

One source of non-determinism in Babel-17 is \emph{probabilistic} non-determism. The expression
\begin{babellisting}
random $n$
\end{babellisting}
returns for an integer $n > 0$ a number between $0$ and $n-1$ such that each number between $0$ and $n-1$ has equal chance of being returned. If $n$ is a dynamic exception, then this exception is propagated, if $n$ is a non-exceptional value that is not an integer $> 0$ then the result is an exception with parameter \babelsrc{DomainError}.

The other source of non-determinism is choice. The expression
\begin{babellisting}
choose $l$
\end{babellisting}
takes a non-empty collection $l$ and returns a member of the collection. The choice operator makes it possible to optimize evaluation in certain cases. For example, in 
\begin{babellisting}
choose (concurrent a, concurrent b)
\end{babellisting}
the evaluator could choose the member that evaluates quicker.

Babel-17 has been designed such that if you take the above two constructs out of the language, it becomes purely functional. If in your semantics of Babel-17 you replace the concept of value by the concept of a probability distribution over values and a set of values, you might be able to view Babel-17 as a purely functional language even \emph{including} \babelsrc{random} and \babelsrc{choose}.

\section{Block Expressions}
So far we have only looked at expressions. We briefly mentioned the term \emph{block expressions} in the description of the \babelsrc{match} function, though.  We will now introduce and explain block expressions.

Block expressions can be used in several places as defined by the Babel-17 grammar. For example, they can be used in a \babelsrc{match} expression to define the value that corresponds to a certain case. But block expressions can really be used just everywhere where a normal expression is allowed: 
\begin{babellisting}
begin
  $b$
end
\end{babellisting}
is a normal expression where $b$ is a block expression. A block expression has the form
\begin{babellisting}
$s_1$
$\vdots$
$s_n$
\end{babellisting}
where the $s_i$ are \emph{statements}. In a block expression both newlines and semicolons can be used to separate the statements from each other. The other means of separation are semicolons.

Statements are Babel-17's primary tool for introducing identifiers. There are several kinds of statements. Three of them will be introduced in this section.

First, there is the \babelsrc{val}-statement which has the following syntax:
\begin{babellisting}
val $p$ = $e$
\end{babellisting}
Here $p$ is a pattern and $e$ is an expression. Its meaning is that first $e$ gets evaluated. If this results in a dynamic exception, then the result of the block expression that the \babelsrc{val}-statement is part of will be that dynamic exception. Otherwise, the result of evaluating $e$ is matched to $p$. If the match is successful then all identifiers bound by the match can be used in later statements of the block expression. If the match fail, then the value of the containing block expression is the dynamic exception \babelsrc{NoMatch}.

Second, there is the \babelsrc{def}-statement which obeys the following syntax for defining the identifier $id$:
\begin{babellisting}
def $id$ $arg$ = $e$
\end{babellisting}
The $arg$ part is optional. If $arg$ is present, then it must be a pattern. Let us call those definitions where $arg$ is present a \emph{function definition}, and those definitions where $arg$ is not present a \emph{simple definition}.  

Per block expression and identifier $id$ there can be either a single simple definition, or there can be several function definitions. If there are multiple function definitions for the same identifier in one block expression, then they are bundled in that order to form a single function.

The defining expressions in  \babelsrc{def}-statements can recursively refer to the other identifiers defined by  \babelsrc{def}-statements in the same block expression. This is the main difference between definitions via \babelsrc{def} and definitions via \babelsrc{val}. Only those \babelsrc{val}-identifiers are in scope that have been defined \emph{previously}, but \babelsrc{def}-identifiers are in scope throughout the whole block expression. Table~\ref{table:legaldef} exemplifies this rule.
\begin{table}
\caption{Legal and illegal definitions}
\begin{tabular}{c@{\hspace{1cm}}c@{\hspace{1cm}}c@{\hspace{1cm}}c}
\begin{babellisting}
val x = y       
val y = 0
\end{babellisting} &
\begin{babellisting}
def x = y       
val y = 0
\end{babellisting} &
\begin{babellisting}
val x = y       
def y = 0
\end{babellisting} &
\begin{babellisting}
def x = y       
def y = 0
\end{babellisting} \\[0.5cm]
\emph{illegal} &
\emph{illegal} &
\emph{legal} &
\emph{legal} 
\end{tabular}
\label{table:legaldef}
\end{table}

Let us assume that  a block expression contains multiple function definitions for the same identifier \babelsrc{f}:
\begin{babellisting}
def f $p_1$ = $e_1$ 
   $\vdots$
def f $p_n$ = $e_n$ 
\end{babellisting}
Then this is (almost) equivalent to 
\begin{babellisting}
def f x = 
  match x
    case $p_1$ => $e_1$
      $\vdots$
    case $p_n$ => $e_n$ 
  end
\end{babellisting}
where \babelsrc{x} is fresh for the $p_i$ and $e_i$. The slight difference between the two notations is that arguments that match none of the patterns will result in a \babelsrc{DomainError} exception for the first notation, and in a \babelsrc{NoMatch} exception for the second.

While definitions only define a single entity per block and identifier, it is OK to have multiple \babelsrc{val}-statements for the same identifier in one block expression, for example like that:
\begin{babellisting}
val x = 1
val x = (x, x)
x
\end{babellisting}
The above block expression evaluates to \babelsrc{(1,1)}; later \babelsrc{val}-definitions overshadow earlier ones.
But note that neither
\begin{babellisting}
val x = 1
def x = 1
\end{babellisting}
nor
\begin{babellisting}
def x = 1
val x = 1
\end{babellisting}
are legal.

Another difference between \babelsrc{val} and \babelsrc{def} is observed by the effects of non-determinism:
\begin{babellisting}
val x = random 2
(x, x)
\end{babellisting}
will evaluate either to \babelsrc{(0, 0)} or to \babelsrc{(1, 1)}. But 
\begin{babellisting}
def x = random 2
(x, x)
\end{babellisting}
can additionally also evaluate to \babelsrc{(0, 1)} or to \babelsrc{(1, 0)} because $x$ is evaluated each time it is used.

Let us conclude this section by describing the third kind of statement. It has the form
\begin{babellisting}
yield $e$
\end{babellisting}
where $e$ is an expression. There is also an abbreviated form of the \babelsrc{yield}-statement which we have already used several times in this section:
\begin{babellisting}
$e$
\end{babellisting}
The semantics of the \babelsrc{yield}-statement is that it appends a further value to the value of the block expression it is contained in. Block expressions have a value just like all other expressions in Babel-17. It is obtained by "concatenating" all values of the \babelsrc{yield}-statements in a block expression. The value of 
\begin{babellisting}
begin
end
\end{babellisting}
is the empty vector \babelsrc{()}. The value of 
\begin{babellisting}
begin
  yield $a$
end
\end{babellisting}
is $a$. The value of 
\begin{babellisting}
begin
  yield $a$
  yield $b$
end
\end{babellisting}
is the vector \babelsrc{($a$,$\ b$)} of length 2 and so on. 

In this section we have introduced the notions of block expressions and statements. Their full power will be revealed in later sections of this document.

\section{Anonymous Functions}
So far we have seen how to define named functions in Babel-17. Sometimes we do not need a name for a certain function, for example when the code that implements this function is actually just as easy to understand as any name for the function. We already have the tools for writing such nameless, or anonymous, functions:
\begin{babellisting}
begin
  def sqr x = x * x 
  sqr
end
\end{babellisting}
is an expression denoting the function that squares its argument. There is a shorter and equivalent way of writing down the above:
\begin{babellisting}
x => x * x
\end{babellisting}
In general, the syntax is
\begin{babellisting}
$p$ => $e$
\end{babellisting}
where $p$ is a pattern and $e$ an expression. The above is equivalent to
\begin{babellisting}
begin
  def f $p$ = $e$ 
  f
end
\end{babellisting}
where \babelsrc{f} is fresh for $p$ and $e$.


There is also a syntax for anonymous functions which allows for several cases:
\begin{babellisting}
(case $p_1$ => $b_1$
    $\vdots$
 case $p_n$ => $b_n$)
\end{babellisting}
is equivalent to 
\begin{babellisting}
begin
  def f $p_1$ = begin $b_1$ end
    $\vdots$
  def f $p_n$ = begin $b_n$ end
  f
end
\end{babellisting}
where $\babelsrc{f}$ is fresh for the $p_i$ and $b_i$.

\section{Objects}
\emph{Object expressions} have the following syntax:
\begin{babellisting}
object 
  $s_1$
  $\vdots$
  $s_n$
end
\end{babellisting}
The $s_i$ are arbitrary statements, with the exception that no \babelsrc{yield}-statements are allowed.  Those $s_i$ that are  \babelsrc{def} statements define the set of messages that the object responds to.

Often you do not want to create objects from scratch but by modifying other already existing objects:
\begin{babellisting}
object + parents
  $s_1$
  $\vdots$
  $s_n$
end
\end{babellisting}
The expression \babelsrc{parents} must evaluate to either a list, a vector or a set. The members of  \babelsrc{parents}
are considered to be the parents of the newly created object, in the order induced by the collection. The idea is that the created object not only understands the messages defined by the $s_i$, but also the messages of the parents. Messages defined via $s_i$ shadow messages of the parents. The messages of an earlier parent shadow the messages of a later one. The parents must have been created via object expressions, too. 

The keyword \babelsrc{this} has currently no meaning in Babel-17. This might change in future versions of Babel-17.

\noindent There is one more way to denote record-like objects:
\begin{babellisting}
{ $m_1$ = $v_1$, $\ldots$, $m_n$ = $v_n$ }
\end{babellisting}
This is equivalent to:
\begin{babellisting}
begin
  val ($w_1$, $\ldots$, $w_n$) = ($v_1$, $\ldots$, $v_n$)
  object
    def $m_1$ = $w_1$
    $\cdots$
    def $m_n$ = $w_n$
  end
end
\end{babellisting}
The empty object is denoted by
\begin{babellisting}
nil
\end{babellisting}
which is equivalent to
\begin{babellisting}
object end
\end{babellisting}


\section{Boolean Operators}

Babel-17 provides the usual boolean operators. They are just syntactic sugar for certain \babelsrc{match} expressions; the exact translations are given in Table~\ref{tab:booleanops}.
\begin{table}
\caption{Boolean Operators}
\begin{tabular}{c|c|c}
\babelsrc{\! a} & \babelsrc{a \& b} &\babelsrc{a | b} \\\hline
 \small
\begin{babellisting}
match a 
  case true => 
    false 
  case false => 
    true
  case _ => 
    exception DomainError
end
\end{babellisting}
 & 
 \small
\begin{babellisting}
match a 
  case true => 
    match b 
      case true => 
        true
      case false => 
        false
      case _ => 
        exception DomainError
    end 
  case false => 
    false
  case _ => 
    exception DomainError
end
\end{babellisting}
 & 
 \small
\begin{babellisting}
match a 
  case false => 
    match b 
      case true => 
        true
      case false => 
        false
      case _ => 
        exception DomainError
    end 
  case true => 
    true
  case _ => 
    exception DomainError
end
\end{babellisting}
\end{tabular}
\label{tab:booleanops}
\end{table}
Babel-17 also has \babelsrc{if}-expressions with the following syntax:
\begin{babellisting}
if $b_1$ then
  $e_1$
elseif $b_2$ then
  $e_2$
  $\vdots$
elseif $b_n$ then
  $e_n$
else
  $e_{n+1}$
end
\end{babellisting}
The \babelsrc{elseif}-branches are  optional. Also, they can be eliminated in the obvious manner via nesting, so that we only need to give the semantics for the expression
\begin{babellisting}
if $b$ then $e_1$ else $e_2$ end
\end{babellisting}
The meaning of above expression is defined to be
\begin{babellisting}
match $b$ 
  case true => $e_1$
  case false => $e_2$
  case _ => exception DomainError 
end
\end{babellisting}
Actually, the  \babelsrc{else} branch is also optional. The notation
\begin{babellisting}
if $b$ then $e$  end
\end{babellisting}
is shorthand for
\begin{babellisting}
if $b$ then $e$  else end
\end{babellisting}



\section{Order}
Babel-17 has a built-in partial order \babelsrc{$\le$}. All other relational operators are defined in terms of this partial order (Table~\ref{tab:relops}).
\begin{table}
\caption{Relational Operators}
\begin{tabular}{c|c}
\textbf{Syntax} & \textbf{Semantics} \\\hline
$a >= b$ & $b <= a$ \\
$a == b$ & $a <= b\ \&\ b <= a$ \\
$a < b$ & $a <= b\ \&\ !(a >= b)$ \\
$a > b$ & $a >= b\ \&\ !(a <= b)$ \\
$a$ $!=$ $b$ & $! (a == b)$ \\
\end{tabular}
\label{tab:relops}
\end{table}
It is possible to chain relational operators like this:
\begin{babellisting}
$a$ <= $b$ <= $c$ > $d$ != $e$ 
\end{babellisting}
Intuitively, the above means 
\begin{babellisting}
$a$ <= $b$ & $b$ <= $c$  & $c$ > $d$  & $d$ != $e$ .
\end{babellisting}
Note that  we always evaluate the operands  of relational operators, even chained ones, only once. For example, the precise semantics of $a <= b <= c <= d <= e$ is 
\begin{babellisting}
begin
  val t = $a$
  val u = $b$
  t <= u &
  begin
    val v = $c$
    u <= v & 
    begin
      val w = $d$
      v <= w & w <= $e$
    end
  end
end
\end{babellisting}
In the above, \babelsrc{t}, \babelsrc{u}, \babelsrc{v} and \babelsrc{w} are supposed to be fresh identifiers.  Also note that if there are operands that are exceptions, then the result of a comparison is a dynamic exception with the same parameter as the first such operand (from left to right).

The partial order is defined by the following laws:
\begin{itemize}
\item  \babelsrc{nil} $< -\infty <  z  < \infty < s <  lv < cexpr < set < map < b$ holds for all
 integers $z$, strings $s$,  lists and vectors $lv$,  constructed expressions $cexpr$, sets $set$, maps $map$ and booleans $b$
 \item booleans are totally ordered and \babelsrc{false} $<$ \babelsrc{true} holds
 \item integers are totally ordered in the obvious way
 \item $-\infty == -\infty$ and $\infty == \infty$ both hold 
 \item strings are totally ordered via lexicographic ordering
\item lists and vectors are partially ordered by the lexicographic ordering 
\item constructed expressions are partially ordered by representing them by the pair consisting of constructor and parameter
\item $! (f <= v) \& ! (v <= f)$ holds for all functions $f$ and arbitrary values $v$
\item sets are partially ordered by first comparing their sizes, and then their elements 
\item maps are partially ordered by first comparing their sizes, then their keys, and then their corresponding values
\item let $U$ consist of all user-defined objects  (i.e., defined via \babelsrc{object}) that cannot receive the message \texttt{representative\_}; then we have  \babelsrc{nil} $<= u < -\infty$  for all $u \in U$; furthermore $U$ is partially ordered by considering first the number of its messages, then the messages, and then the corresponding message values
\item let $a$ be a user-defined object  (i.e., defined via \babelsrc{object}) that has the message \texttt{representative\_}; let $ra$ be the result of sending  \texttt{representative\_} to $a$; then $a <= b$ is defined by $ra <= b$, and $b <= a$ is defined via $b <= ra$ for all $b$.
\end{itemize}
The order does not distinguish between lists and vectors. For example, we have 
\begin{babellisting}
(1, 2, 3) == [1, 2, 3]
\end{babellisting}

\section{Sets and Maps}\label{sec:setsandmaps}
Sets and maps are built into Babel-17. For example, the set consisting of 3, 42 and $\infty$ can be written as
\begin{babellisting}
{42, $\infty$, 3}
\end{babellisting}
Sets are always sorted. The sorting order is Babel-17's built-in partial order, and every set forms a totally ordered subdomain of this partial order. Future versions of Babel-17 might allow the set order to be different from the built-in partial order. Adding or removing an element $e$ from a set $S$ is only well-defined when the elements of $S$ together with $e$ are totally ordered by the partial order of $S$. The same holds for testing if an element is in a set. Table~\ref{tab:setops} shows the built-in operations for sets. 
\begin{table}
\caption{Set Operations}
\begin{tabular}{c|c}
$S$ \verb!+! $e$ & \tabparbox{set created by inserting the element $e$  into the set $S$} \\\hline
$S$ \verb!-! $e$ & \tabparbox{set created by removing the element $e$  from the set $S$} \\\hline
$S$ \verb!++! $T$ & \tabparbox{set created by inserting all elements of $T$  into the set $S$} \\\hline
$S$ \verb!--! $T$ & \tabparbox{set created by removing all elements of $T$ from the set $S$} \\\hline
$S$ \verb!**! $T$ & \tabparbox{cartesian product of the set $S$ and the elements of $T$} \\\hline
$S$ \verb!*! $T$ & \tabparbox{set created by removing all elements from the set $S$ which are not an element of $T$} \\\hline
$S$ $e$ & \tabparbox{tests wether $e$ is an element of $S$}\\\hline
$S / f$  & \tabparbox{map created by applying the function $f$ to the elements of $S$}
%\babelsrc{$S$.reorder $\ p$} & \tabparbox{set created by reordering $S$ according to the partial order $p$; in case of duplicate elements, the greater of the elements relative to the order of $S$ is kept}
\end{tabular}
\label{tab:setops}
\end{table}

Maps map finitely many keys to values. For example, the map that maps 1 to 2 and 4 to 0 is written as
\begin{babellisting}
{1 -> 2, 4 -> 0}
\end{babellisting}
The empty map is denoted by 
\begin{babellisting}
{->}
\end{babellisting}
Maps also have always a partial order associated with them, in the current version of Babel-17 this is always Babel-17's built-in partial order.  Operations on maps are only well-defined if all keys of the map together with all other involved keys are totally ordered by the associated order. Table~\ref{tab:mapops} shows the built-in operations for maps.
\begin{table}
\caption{Map Operations}
\begin{tabular}{c|c}
$M$ \verb!+! $(k, v)$ & \tabparbox{map created from the map $M$ by associating $k$ with $v$}\\\hline
$M$ \verb!-! $k$ & \tabparbox{map created from the map $M$ by removing the key $k$}\\\hline
$M$ \verb!++! $N$ &  \tabparbox{map created from the map $M$ by adding the key/value pairs that are elements of $N$}\\\hline
$M$ \verb!--! $S$ & \tabparbox{map created from $M$ by removing all keys that are not elements of $S$}\\\hline
$M$ \verb!**! $N$ & \tabparbox{if $(k_M,v_M)$ is contained in $M$ and 
$(k_N, v_N)$ is contained in $N$ such that $k_M == k_N$, then $(k_M, (v_M, v_N))$ is contained in the new map;
if $k_M$ is a key of $M$ but not of $N$ then $(k_M, \babelsrc{Left}\ k_M)$ is an element of the new map; 
finally, if $k_N$ is a key of $N$ but not of $M$ then $(k_N, \babelsrc{Right}\ k_N)$ is an element of the new map} \\\hline
$M$ \verb!*! $T$ & \tabparbox{map created by removing all keys from the map $M$ which are not elements of  $T$} \\\hline
$M$ $k$ & \tabparbox{returns the value $v$ associated with $k$ in $M$, or returns a dynamic exception with parameter \texttt{DomainError} if no such value exists} \\\hline
$M \% f$ & \tabparbox{map created by applying the function $f$ to the key/value pairs of $M$; $f$ takes a key/value pair and returns a value}\\\hline
$M / f$ & \tabparbox{map created by applying the function $f$ to the values of $M$; $f$ takes a value and returns a value}
%\babelsrc{$M$.reorder $\ p$} & \tabparbox{map created by reordering $M$ according to the partial order $p$; in case of duplicate keys, the greater of the keys relative to the order of $M$ is kept}
\end{tabular}
\label{tab:mapops}
\end{table}

Pattern matching is available also for sets and maps. The pattern 
\begin{babellisting}
{$p_1$, $\ldots$, $p_n$}
\end{babellisting}
matches a set that has $n$ elements $e_1$, $\ldots$, $e_n$ such that $p_i$ matches $e_i$ and $e_i < e_j$ for $i < j$. The pattern
\begin{babellisting}
{$p_1$, $\ldots$, $p_n$, $\delta$}
\end{babellisting}
matches a set that has $m \ge n$ elements such that its first $n$ elements match the patterns $p_i$, and the set consisting of the other $m-n$ elements matches the $\delta$-pattern. 

Similarly, the pattern
\begin{babellisting}
{$p_1$ -> $q_1$, $\ldots$, $p_n$ -> $q_n$}
\end{babellisting}
matches a map consisting of $n$ key/value pairs such that the key/value pairs match the pattern pairs in order.
The pattern \babelsrc{\{ -> \}} matches the empty map. Map patterns can have a $\delta$ pattern, too.

\section{Syntactic Sugar}
One of the goals of Babel-17 is that Babel-17 code is easy to read and understand. I have found that allowing arbitrary user-specific extensions to the syntax of code is definitely not helping to achieve this goal. Nevertheless, a bare minimum of syntactic sugar is necessary to support the most basic conventions known from arithmetic; for example, one should be able to write \texttt{3 + 5} to denote the addition of the integer 3 and the integer 5.

The programmer can use some of this syntactic sugar when defining her own objects. For example, \texttt{3 + 5} is just syntactic sugar for 
\begin{babellisting}
3.plus 5
\end{babellisting} 
Table~\ref{tab:syntacticsugar} lists all syntactic sugar of Babel-17 that is also available to the programmer. 
\begin{table}
\caption{Syntactic Sugar}
\begin{tabular}{c|c}
\textbf{Sugared} & \textbf{Desugared} \\\hline\hline
$a$ \verb!+! $b$ & \babelsrc{$a$.plus_ $\ b$} \\\hline
$a$ \verb!-! $b$ & \babelsrc{$a$.minus_ $\ b$} \\\hline
\verb!-! $a$ & \babelsrc{$a$.uminus_} \\\hline
$a$ \verb!*! $b$ & \babelsrc{$a$.times_  $\ b$} \\\hline
$a$ \verb!/! $b$ & \babelsrc{$a$.quotient_  $\ b$} \\\hline
$a$ \verb!div! $b$ & \babelsrc{$a$.div_  $\ b$} \\\hline
$a$ \verb!mod! $b$ & \babelsrc{$a$.mod_  $\ b$} \\\hline
$a$ \verb+^+ $b$ & \babelsrc{$a$.pow_  $\ b$} \\\hline
$a$ \verb!++! $b$ & \babelsrc{$a$.plus__ $\ b$} \\\hline
$a$ \verb!--! $b$ & \babelsrc{$a$.minus__ $\ b$} \\\hline
$a$ \verb!**! $b$ & \babelsrc{$a$.times__  $\ b$}\\\hline
$a$ \verb!//! $b$ & \babelsrc{$a$.quotient__  $\ b$}\\\hline
$a$ \verb!to! $b$ & \babelsrc{$a$.to_ $\ b$}\\\hline
$a$ \verb!downto! $b$ & \babelsrc{$a$.downto_  $\ b$}\\\hline
$f$ $x$ &  \babelsrc{$f$.apply_  $\ x$}
\end{tabular}
\label{tab:syntacticsugar}
\end{table}
The availability of syntactic sugar for function application means that you can let your own objects behave as if they were functions. 

\section{Memoization}
Babel-17 supports \emph{memoization}. 
In those places where \babelsrc{def}-statements can be used, \babelsrc{memoize}-statements can be used, also. A \babelsrc{memoize}-statement must always refer to \babelsrc{def}-statements in the same scope. Babel-17 differentiates two kinds of memoization, \emph{strong} and \emph{weak}. A \babelsrc{memoize}-statement has the following syntax:
\begin{babellisting}
memoize $\metababel{ref}_1 \hdots \metababel{ref}_n$
\end{babellisting}
The $\metababel{ref}_i$ are either of the form $\metababel{id}$ to indicate strong memoization, or of the form $(\metababel{id})$ to signal weak memoization. In both cases $\metababel{id}$ refers to the \babelsrc{def}-statement being memoized. As an example, here is the definition of the weakly memoized fibonacci-sequence:
\begin{babellisting}
memoize (fib)
def fib 0 = 0
def fib 1 = 1
def fib n = fib (n-1) + fib (n-2)
\end{babellisting}
The difference between weak and strong memoization is that strong memoization always remembers a value once it has been computed; weak memoization instead may choose not to remember computed results in certain situations, for example in order to free memory in low memory situations. Note that all arguments to the same memoized function must be totally ordered by the built-in partial order. 

\section{Linear Scope}
We are now ready to explore the full power of block expressions and statements in Babel-17. 

First, we extend the syntax of \babelsrc{val}-statements such that it is legal to leave out the keyword \babelsrc{val} in certain situations. Whenever the situation is such that it is legal to write
\begin{babellisting}
$a$ = $\textit{expr}$
\end{babellisting}
for a variable identifier $a$, we say that $a$ is in \emph{linear scope}. We call the above kind of statements \emph{assignments}. A necessary condition for $a$ to be in linear scope is for $a$ to be in scope because of a previous \babelsrc{val}-statement or a pattern match. 
The idea behind linear scope is that when the program control flow has a linear structure, then we can make assignments to variables in linear scope without leaving the realm of purely functional programming.

The following two expressions are equivalent:
\begin{center}
\begin{tabular}{ccc}
\begin{babellisting}
begin
  val x = $a$ 
  val y = $b$
  val x = $c$
  $d$
end
\end{babellisting}
& \hspace{2cm} &
\begin{babellisting}
begin
  val x = $a$ 
  val y = $b$
  x = $c$
  $d$
end
\end{babellisting}
\end{tabular}
\end{center}
So far, \babelsrc{val}-statements and assignments have indistinguishable semantics. The differences start to show when we look at nested block expressions:
\begin{center}
\begin{tabular}{ccccc}
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    val y = 4 * x
  end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    y = 4 * x
  end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1 
  val y = 2
  begin
    val x = 3
    val y = 0
    y = 4 * x
  end
  (x, y)
end
\end{babellisting}\\\hline
evaluates to $(1, 2)$ & &
evaluates to $(1, 12)$ & &
evaluates to $(1, 2)$ \\[0.5cm]
\end{tabular}
\end{center}
The above examples show that the effect of dropping the \babelsrc{val} in a \babelsrc{val} statement is that the binding of an identifier becomes visible at that level within the linear scope where it has last been introduced via a \babelsrc{val} statement or via a pattern match.

Linear scope spreads along the statements and nested block expressions of a block expression. It usually does not spread into expressions. An exception are certain expressions that can also be viewed as statements. We call these expressions \emph{control expressions}. For example, in
\begin{babellisting}
begin
  val x = 1 
  x = 2
  val y = $a$ * $b$
 (x, y)
end
\end{babellisting}
the linear scope of $x$ does not extend into the expressions $a$ and $b$, because $a * b$ is not a control expression. Therefore the above expression will always evaluate (assuming there is no exception) to a pair which has $2$ as its first element. But for example in
\begin{babellisting}
begin
  val x = 1 
  x = 2
  val y = 
     begin
        $s_1$
        $\vdots$
        $s_n$
     end
  (x, y)
end
\end{babellisting}
the linear scope of $x$ extends into $s_1$ and spreads then along the following statements. Therefore the first element of the pair that is the result of evaluating above expression depends on what happens in the $s_i$.
Here are three example code snippets that further illustrate linear scope:
\begin{center}
\begin{tabular}{ccccc}
\begin{babellisting}
begin
  val x = 1
  val y = 
    begin 
      x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1
  val y = 3 *
    begin 
      x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}
& \hspace{1cm} &
\begin{babellisting}
begin
  val x = 1
  val y = 3 *
    begin 
      val x = 2 
      x+x 
    end
  (x, y)
end
\end{babellisting}\\\hline
evaluates to $(2, 4)$ & &
illegal & &
evaluates to $(1, 12)$ \\[0.5cm]
\end{tabular}
\end{center}

These are the control expressions that exist in Babel-17:
\begin{itemize}
\item \babelsrc{begin ... end}
\item \babelsrc{if ... end}
\item \babelsrc{match ... end}
\item \babelsrc{for ... end}
\item \babelsrc{while ... end}
\end{itemize}
The last two control expressions are loops and explained in the next section. The first three have already been treated without delving too much into their statement character. We have already seen how  \babelsrc{begin ... end} is responsible for nesting block expressions, when it is used as a statement.  Just as  the \babelsrc{begin ... end} expression may be used as a statement, 
you can also use all other control expressions as statements, for example:
\begin{babellisting}
begin
  val x = random 2
  if x == 0 then
    x = 100
  else
    x = 200
  end
  x + x
end
\end{babellisting}
This expression will evaluate either to $200$ or to $400$.

For \babelsrc{if}-statements the \babelsrc{else}-branch is optional, but \babelsrc{match}-statements throw a \babelsrc{NoMatch} exception if none of the patterns matches. 

\section{With}
By default, all yielded values of a block expression are collected into a list which collapses in the case of a single element. The programmer might want to deviate from this default and collect the yielded values differently, for example to get rid of the collapsing behavior. The \babelsrc{with} expression allows her to do just that. Its syntax is:
\begin{babellisting}
with $c$ do 
  $b$
end
\end{babellisting}
where $c$ is a \emph{collector} and $b$ is a block expression. A collector $c$ is any object that 
\begin{itemize}
\item responds to the message \verb+collector_close_+,
\item and returns via $c$.\verb+collector_add_+ $x$ another collector.
\end{itemize}
Lists, vectors, sets, maps and strings are built-in collectors which the programmer can use out-of-the-box; apart from that she can implement her own collectors, of course.

Here is an example where we use a set as a collector:
\begin{babellisting}
with {4} do
  yield 1
  yield 2
  yield 1
  10
end
\end{babellisting}
Above expression evaluates to \babelsrc{\{1, 2, 4, 10\}}.

\section{Loops}\label{sec:loops}
This is the syntax for the \babelsrc{while}-loop:
\begin{babellisting}
while $c$ do
  $b$
end
\end{babellisting}
Here $c$ must evaluate to a boolean and $b$ is a block expression. For example, here is how you could code the euclidean algorithm for calculating the greatest common divisor:
\begin{babellisting}
def gcd (a,b) = begin
  while b != 0 do
    (a, b) = (b, a mod b)
  end
  a
end
\end{babellisting}

There is also the \babelsrc{for}-loop. It has the following syntax:
\begin{babellisting}
for $p$ in $C$ do
  $b$
end
\end{babellisting}
In the above $p$ is a pattern, $C$ is a \emph{collection} $C$, and $b$ is a block expression.
The idea is that above expression iterates through those elements of the \emph{collection} $C$ 
which match $p$; for each successfully matched element, $b$ is executed. 

An object $C$ is a collection if it handles the message \texttt{iterate\_}
\begin{itemize}
\item by returning \texttt{()} if it represents the empty collection,
\item or otherwise by returning \texttt{($e$, $C'$)} such that $C'$ is also a collection.
\end{itemize}

Here is an example of a simple \babelsrc{for}-loop expression:
\begin{babellisting}
begin
  val s = [10, (5, 8), 7, (3,5)]
  with {->} : for (a,b) in s do
    yield (b,a)
  end
end
\end{babellisting}
evaluates to \babelsrc{\{8 -> 5, 5 -> 3\}}.

Using \babelsrc{for}-loops in combination with linear scope it is possible to formulate all of those \emph{fold}-related functionals known from functional programming in a way which is easier to parse (and remember) for most people. Let us for example look at a function that takes a list $m$ of integers $[a_0, \ldots, a_n]$ and an integer $x$ as arguments and returns the list
\begin{displaymath}
	[q_0, \ldots, q_n] \quad \text{where} \quad q_k = \sum_{i=0}^k a_i\, x^i
\end{displaymath}
The implementation in Babel-17 via a loop is straightforward, efficient and even elegant:
\begin{babellisting}
m => x => 
  with [] do 
    val y = 0
    val p = 1
    for a in m do 
      y = y + a*p
      p = p * x
      yield y
    end
 end
\end{babellisting}

The built-in collections that can be used with for-loops are the usual suspects: lists, vectors, sets, maps and strings. Of course you can define your own custom collections. There is even a pattern you can use for matching against an arbitrary collection:
\begin{babellisting}
(for $p_1$, $\ldots$, $p_n$ end)
\end{babellisting}
and the corresponding $\delta$ pattern
\begin{babellisting}
(for $p_1$, $\ldots$, $p_n$, $\delta$ end)
\end{babellisting}
match collections with exactly $n$ or at least $n$ elements, respectively. 
\end{document}  