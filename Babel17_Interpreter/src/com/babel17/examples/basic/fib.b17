/*there are statements and expressions
what about control expressions?
If control expressions appear in the position of statements

control construct
  - a control construct is either a control statement
  - or a control expression
not the point*/


// This program should compile, but does not:

val f = a => b => begin
                    b = 2
                    a = 5
                    a*b
                  end
val x = 0
begin x=1; x end * begin x=x+2; x end


/*val (2, exception _) = 0
val x = begin
  yield 10
  nil
end

val _ = object+() end

val (a,b) = 10

val _ = 8
val x.oops = 0
val x = {a->10, b->12, n->9}

begin
  val a = 2
  val b = 3
  //10
end*/

/*val a = 0
x.a = t
val x =
  begin
    val b = t
    object(x)
      def a = b
    end
  end

val _ = object(
  val a = 0
  begin
    a = 2
  end
  def r = 2
end*/

/*
  val x = begin
  val a = 10
  val u = a*a
  yield 10
end
*/

/*
def f = random 7
val z = f
def g = z
val w = 0
def g = 0

val u = h
val z = 0
def h = g2
def g2 = z

begin
  def f (-9) = 0
  val x = (3 * with (): begin end)
end

val q =
  object
  private:
    val a = b
    def b = 0
  public:
    def lol 0 = 1
    private def lol 1 = 2
  end

z = 3


val x = 2
val rüber = 0
rÜber = 1
module a.what
  yield ()
  val x = what
  x = what
  module b
    val u = (1,0)
  end
  val x = b.cool
end

~ C
val //a_ID = 0
a_Id = 1
a_id = 2
val (xa, xa) = 10
val (xa, xA) = 20
def f {C n, ...} = n
if n < 3 then 0 elseif true then x
end
begin end
val x = 0
val (x, ...) = ∞;
while false do 
x = (1,2)
y = 5
end
for i in {1,2,3} do
  x = Whatever (i*i)
end
with {} match 2
case a => 0
case b => 1
end

memoize cool

begin
  "cool"
  memoize fib (whatever) cool great (sowhat) 
  memoize (token)
end
yield 5*4

module cool.lecker
  private module great
  end
  4
end

(case x => 5 case y => 10 case _ => 9)

val y = 4

object
  val x = 2
  val y = 3*this
  y = 3*z+w
  def z = 3*this
  val w = 0
end*/